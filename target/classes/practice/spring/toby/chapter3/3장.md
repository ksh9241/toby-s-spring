# 템플릿
템플릿이란 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있는데 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

##### 리소스 반환과 close()
Connection과 PreparedStatement는 보통 풀(pool) 방식으로 운영된다. 미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할 때 이를 할당하고, 반환하면 다시 풀에 넣는 방식으로 운영된다. 요청이 매우 많은 서버환경에서는 매번 새로운 리소스를 생성하는 대신 풀에 미리 만들어둔 리소스를 돌려가며 사용하는 편이 훨씬 유리하다. 대신 사용한 리소스는 빠르게 반환해야 한다. 그렇지 않으면 풀에 있는 리소스가 고갈되고 결국 문제가 발생한다. close()는 사용된 리소스를 반환해주는 메서드이다.

##### 분리와 재사용을 위한 디자인 패턴 적용
DB커넥션 연결과 같이 Dao에서 지속적으로 사용하는 코드가 메서드 단위로 반복적인 호출이 일어난다. 중복코드를 처리하는 방법으로는 변하는 부분과 변하지 않는 부분을 찾아서 처리하면 된다.
예제로 chapter3의 UserDao 클래스에서 PreparedStatement 의 부분을 제외한 Connection, ResultSet 등의 부분은 변하지 않는다. 원래는 변하지 않는 부분의 코드를 메서드로 만드는 것이 낫지만 변하는 부분이 변하지 않는 부분 중간에 껴있기 때문에 변하는 부분을 메서드로 만들고 하나의 메서드에서 재사용하는 방법으로 리팩토링을 선택하였다.

##### 템플릿 메서드 패턴의 적용
기존에 makeStatement 메서드를 추상메서드로 만들어서 자식클래스에서 재정의한 후 변하지 않는 부분에서 클래스를 호출하여 사용한다. 하지만 장점보다 단점이 더 많이 보인다. Dao 내의 메서드가 많을수록 서브클래스의 개수가 증가하기 때문이다.

##### 전략 패턴의 적용
개방 폐쇄 원칙을 잘 지키는 구조이면서도 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.
Service와 ServiceImple의 경우를 생각해볼 수 있다.

##### 테스트 클래스에서 배운점
테스트케이스는 추상클래스를 테스트할 때 extends 한 클래스로 오브젝트를 생성해서 테스트하여야 한다.

##### DI
앞에서 사용한 예로 컨텍스트(UserDao) 가 필요로 하는 전략 (ConnectionMaker.interface) 의 특정 구현 클래스 (DSimpleConnectionMaker) 오브젝트를 클라이언트 (UserDaoTest)에서 생성하여 제공해주는 방법. (DI) 위의 설명이 DI의 흐름이다. DI는 다양한 형태로 적용 할 수 있다. DI의 가정 중요한 개념은 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것이다. 이 개념만 따른다면 DI를 이루는 오브젝트와 구성요소 구조나 관계는 다양하게 만들 수 있다. 일반적으로 DI는 두 개의 오브젝트와 두 오브젝트를 연결해주는 오브젝트 팩토리(DI 컨테이너), 그리고 이를 사용하는 클라이언트라는 4개의 오브젝트 사이에서 일어난다.

##### 전략과 클라이언트의 동거
지금까지 예제를 하면서 많은 중복코드가 해결되고 깔끔해졌지만 그에 따른 문제점도 발생했다. 전략패턴을 사용하게되면 상속받을 서브클래스를 메서드 단위로 만들어야되기 때문에 전략패턴을 사용하지 않을 때보다 훨씬 많은 클래스를 만든다.
첫번째 해결방법은 클래스파일을 각 메서드안에 내부 클래스 파일로 만드는 것이다. 마치 로컬 변수를 선언하듯이 선언하면 된다. 로컬클래스는 선언된 메서드 내에서만 사용할 수 있다. 또한 메서드 내부에 로컬클래스가 존재하기 때문에 가독성도 나쁘지 않다.

##### 중첩클래스의 종류
다른 클래스 내부에 정의되는 클래스를 중첩클래스(nested class) 라고 한다. 중첩 클래스는 독립적으로 오브젝트로 만들어질 수 있는 스태틱 클래스와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스(inner class)로 구분된다. 내부 클래스는 다시 범위 (scope)에 따라 세 가지로 구분된다. 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스와 메서드 레벨에 정의되는 로컬클래스, 그리고 이름을 갖지 않는 익명 내부 클래스다. 익명 내부 클래스의 범위는 선언된 위치에 따라서 다르다.

##### 익명내부클래스 (nonymous inner class)
익명 내부 클래스는 이름을 갖지 않는 클래스이다. 오브젝트 생성이 결합된 형태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용한다. 클래스를 재사용할 필요도 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.
ex) new 인터페이스명() { 클래스 본문 };
# 오브젝트와 의존관계
스프링에 가장 관심을 많이 두는 대상은 오브젝트이다. 오브젝트에 대한 관심은 애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지 전 과정을 진지하게 생각해볼 필요가 있다. 더 나아가 오브젝트는 어떻게 설계돼야 하는지에 대해서도 살펴봐야 한다.

### 1.1 초난감 DAO
DAO : (Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.
자바빈 : 자바빈(JavaBean) 은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. 자바빈의 몇 가지 코딩 관례는 JSP 빈, EJB 와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다.
	- 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
	- 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다.
	
### 1.2 관심사의 분리
개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다. 변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다. 프로그래밍 기초 개념 중에 관심사의 분리(Separation of Concerns)라는 게 있다. 이를 객체지향에 적용해보면, 관심이 같은 것끼리는 하나의 객체 안에 모이게 하여 관심이 다른 것과 서로 영향을 주지 않도록 분리하는 것이다.

리팩토링 : 기존의 코드를 외부의 동작방식에는 변화없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하게되면 코드 내부 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 더 효율적으로 대응할 수 있다. 리팩토링이 절실히 필요한 코드를 나쁜 냄새라고 부르기도 한다. 이런 코드는 중복이 많고 코드가 지저분하다는 것이다.

디자인 패턴 : 디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 모든 패턴에는 간결한 이름이 있어서 잘 알려진 패턴을 적용하고자 할 때 간단히 패턴 이름을 언급하는 것만으로도 설계의 의도와 해결책을 함께 설명할 수 있다는 장점이 있다. 디자인 패턴의 구조는 크게 두 가지로 클래스 상속과 오브젝트 합성이다.
	- 템플릿 메소드 패턴 : 상속을 통해 슈퍼클래스(부모클래스) 의  기능을 확장할 때 사용하는 대표적인 방법이다.
	- 팩토리 메서드 패턴 : 상속을 통한 기능을 확장하는 패턴이다. 커스텀 팩토리 클래스를 만든 뒤 인풋값에 따른 아웃풋을 만들어낸다. (ex : 성별클래스 extends 성별팩토리, 남자 extends 성별, 여자 extends 성별 의 클래스가 있을 때 성별팩토리에 인풋값에 따라 남자 혹은 여자의 대한 아웃풋이 나온다.)
	- 전략 패턴 : main class -> dao -> connection 구조의 형태의 디자인 패턴을 시각으로 보면 전략패턴에 해당한다고 볼 수 있다. 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
	- 싱글톤 패턴 : 싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 주로 하나만 존재하도록 강제하는 패턴이다. 디자인 패턴 중 가장 자주 활용되는 패턴임과 동시에 가장 많은 비판을 받는 패턴이기도 하다. 매우 조심해서 사용하거나 피해야 할 패턴이라는 말도 많다.

### 관계설정 책임의 분리
Dao의 A클래스와 커넥션의 B클래스의 불필요한 의존관계를 없애기 위해서는 Dao에 직접적으로 커넥션을 생성할 수 있지만 이렇게 생성하게 될 경우 B클래스의 수정이 A클래스를 무조건적으로 거쳐서 진행해야 하기 때문에 불필요한 의존관계가 형성된다. 따라서 A클래스의 생성자 파라미터에 B클래스를 파라미터로 받아서 커넥션하게 되면 불필요한 의존관계가 사라진다. (1장의 UserDao, UserDaoTest.java 확인)

### 원칙과 패턴
- 개방 폐쇄 원칙( Open-Closed-Principle [OCP] ) : 이 원칙은 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다. 예로 UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려있다. 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀있다고 말할 수 있다.

- 객체지향 설계 원칙 (SOLID) : 객체지향 설계 원칙은 좀 더 일반적인 상황에서 적용 가능한 설계 기준이라고 볼 수 있다. SOLID란 5가지 객체지향 설계 원칙을 말한다.
	- SOLID 의 5가지 원칙
	- SPP (The Single Responsibility Principle) : 단일 책임 원칙
	- OCP (The Open Closed Principle) : 개방 폐쇄 원칙
	- LSP (The Liskov Substitution Principle) : 리스코프 치환 원칙
	- ISP (The Interface Segregation Principle) : 인터페이스 분리 원칙
	- DIP (The Dependency Inversion Principle) : 의존관계 역전 원칙

### 높은 응집도와 낮은 결합도
높은 응집도와 낮은 결합도 : 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도 라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능하다. 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.

- 높은 응집도
응집도가 높다는 것은 변화할 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수 있다.

- 낮은 결합도
낮은 결합도는 높은 응집도보다 더 민감한 원칙이다. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다.

### 제어의 역전

##### 제어권의 이전을 통한 제어관계 역전
간단하게 프로그램의 제어 흐름 구조가 뒤바뀐 것이라고 설명할 수 있다.
일반적인 프로그램 흐름 : 프로그램 시작지점 (main()과 같은) -> 사용할 오브젝트 결정 -> 결정한 오브젝트 생성 -> 생성된 오브젝트 내 메서드 호출 -> 메서드 내 다음 사용 할 것을 결정하고 호출 (반복) -> 원하는 결과 출력 -> 종료.

제어의 역전 : 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 사용되는지 알 수 없다. 프로그램 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.
예로 서블릿을 볼 수 있다. 서블릿은 엔트리 포인트 (main()) 가 있어서 직접 실행시킬 수 없다. 대신 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안에 메소드를 호출한다.
정리하자면 오브젝트가 필요한 오브젝트를 능동적으로(클래스 내에서 직접 실행) 이 아닌 수동적으로 (다른 정의된 클래스에서 참조 (refference) 하는 것이 제어의 역전 (Inversion of Control) 이다.

##### 애플리케이션 컨텍스트의 동작방식
client 요청 -> ApplicationContext getBean() 요청받은 빈을 빈 목록에서 조회 
-(목록에 없을 시)-> Configuration에 생성 요청 -> configuration에서 빈등록 및 요청받은 오브젝트 생성 후 client에 반환
-(목록에 있을 시 )-> 요청받은 오브젝트 생성 후 client에 반환
-> client 는 반환된 오브젝트 사용.

- ApplicationContext 사용 시 장점
	- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다. : 애플리케이션이 발전하면 IoC를 적용한 오브젝트도 계속 추가될 것이다. 클라이언트가 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야 할지 알아야 하고, 필요할 때마다 팩토리 오브젝트를 생성하는 번거로움이 있다. 애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리를 알아야하거나 직접 사용할 필요가 없다.
	- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다. : 오브젝트가 만들어지는 방식, 시점과 전략, 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
	- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다. : 타입만으로 빈을 검색하거나 특별한 어노테이션 설정이 되어 있는 빈을 찾을 수도 있다.

##### 스프링 용어 정리
- 빈 (Bean) : 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트.
- 빈 팩토리 (Bean Factory) : 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 빈등록, 생성 조회 외에 부가적인 빈을 관리하는 기능을 담당함. 보통 빈팩토리를 사용하지 않고 이를 확장한 Application Context를 사용함.
- 애플리케이션 컨텍스트 (ApplicationContext) : 빈팩토리를 확장한 IoC컨테이너다. 빈팩토리 + 스프링이 제공하는 추가적인 서비스
- 설정정보/설정 메타정보 (Configuration metadata) : 애플리케이션이 IoC를 적용하기 위해 사용하는 메타정보를 말한다. 애플리케이션 형상정보라고도 말한다.

##### 오브젝트의 동일성과 동등성
동일성 : 동일하다는 것은 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. (heap area의 같은 주소의 오브젝트를 바라봄) [두 개의 인스턴스가 하나의 오브젝트를 바라봄]
동등성 : 두개의 오브젝트가 존재하나 두개의 오브젝트가 동등성의 기준에 따라 오브젝트의 정보가 동등하다고 판단하는 것이다. [두 개의 인스턴스가 각각의 오브젝트를 바라봄]

Application Context의 경우 처음 생성한 빈을 호출할 때마다 참조하기 때문에 메모리 관리가 유용하다. 

##### 서버 애플리케이션과 싱글톤
스프링이 싱글톤으로 빈을 생성하는 이유 : 스프링의 주요 적용 대상은 자바 엔터프라이즈 기술을 사용하는 서버환경이다. 대규모의 엔터프라이즈 서버환경의 경우 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터 요청을 받아 처리한다. 그런데 매번 요청이 올 때마다 오브젝트(빈)을 새로 만들어 처리한다고 한다면 아무리 GC가 좋아졌다고 해도 성능저하가 생기기 마련이다. 그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.

서비스 오브젝트 : 서블릿은 가장 기본이 되는 서비스 오브젝트이다. 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.

##### 싱글톤 패턴의 한계
자바에서 싱글톤을 구현하는 방법
- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메서드인 getInstance()를 만들고 이 메서드가 최초 실행될 때 한번만 오브젝트를 생성한다.

```JAVA
// 싱글톤 패턴을 적용한 예시
public class UserDao {
	private static UserDao INSTANCE;

	private UserDao(ConnectionMaker connectionMaker) {
		this.connectionMaker = connectionMaker;
	}

	public static synchronized UserDao getInstance() {
		if (INSTANCE == null) INSTANCE = new UserDao();
		return INSTANCE;
	}
}
```

싱글톤 패턴의 문제점
- private 생성자를 갖고 있기 때문에 상속 불가. 이 말은 결합도가 높아진다는 말이다. 
- 테스트하기가 힘들다. 
	- 싱글톤이 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다. 생성자 초기화 과정에서 필요한 오브젝트를 주입하기도 힘들어서 직접 만들어서 사용할 수 밖에 없다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
	- 여러개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생성되기 때문에 싱글톤으로서의 가치가 떨어진다.
- 전역상태를 만들 수 있기 때문에 바람직하지 못하다.
	- 싱글톤의 경우 스태틱 메서드를 이용해 언제든지 싱글톤에 접근할 수 있기 때문에 전역 상태로 사용되기 쉽다. 아무객체나 자유롭게 접근하고 수정하는 전역상태를 갖는 것은 객체지향 프로그래밍에서 권장하지 않은 프로그래밍 모델이다. 싱글톤을 사용할 바에는 스태틱 필드와 메서드로만 구성된 클래스를 사용하는 편이 낫다.

##### 싱글톤 레지스트리
스프링의 장점은 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 이것이 바로 싱글톤 레지스트리이다. 싱글톤 레지스트리는 private , static 등 권장하지 않은 프로그래밍 모델 기법을 사용하여 만드는 것이 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다. 이유는 오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문이다.

##### 싱글톤 사용 시 주의사항
단일 스레드 환경에서는 문제가 없지만 멀티스레드 환경이라면 상태정보를 내부에 갖고있지 않는 무상태 (stateless) 방식으로 만들어져야 한다. 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 않는다. 물론 읽기전용 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 공유하는 것은 아무 문제가 없다.

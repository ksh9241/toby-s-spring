# 테스트
스프링을 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다.

##### 웹을 통한 DAO 테스트 방법의 문제점
DAO 뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다. 또한 테스트를 진행하는 중에 에러가 발생했을 경우 문제를 찾아야 하는 수고도 필요하다. 하나의 테스트를 수행하는데 참여하는 클래스와 코드가 너무 많기 때문이다.

##### 작은 단위 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 단위테스트는 개발한 기능이 원하는대로 정상작동하는지 확인할 수도 있으며, 이런 단위테스트를 하지않고 나중에 통합테스트에서 문제가 발생한다면 찾는것도, 해결하는 시간도 훨씬 오래 걸릴 것이다.

##### 자동수행 테스트 코드
테스트를 하기 위해 url을 입력하고 인풋값을 작성하고 브라우저를 실행하는 등 테스트를 수동으로 작업해야 하는 양이 많아질수록 테스트를 하기가 싫어진다. 1장에서 UserDaoTest 클래스의 경우 UserDao 오브젝트를 생성하고 DI를 통해 생성된 DB커넥션의 빈을 주입한 뒤 값만 입력하게된다면 IDE에서 1초면 테스트를 실행할 수 있었다. 이처럼 테스트는 최대한 간단하고, 자주 수행해도 부담이 없어야 좋다.

##### 수동확인 작업의 번거로움
main() 메서드에서 테스트코드를 작성하는 것은 자동으로 수행하도록 만들어졌다. 하지만 테스트의 결과값을 확인하는 것은 개발자의 몫이다. main() 메서드는 단순하게 콘솔에 우리가 원하는 값을 출력할 뿐이다.이렇게 결과를 개발자가 확인해야 하기때문에 완전 자동화된 테스트코드라고 말할 수 없다.

##### 실행 작업의 번거로움
아무리 main() 메서드로 간단히 실행할 수 있다고 하더라도 테스트케이스가 수백개가 된다면 수백개의 main 메서드를 실행하는 것도 쉽지않을 것이다.

##### JUnit
JUnit은 프레임워크이다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main() 메서드도 필요없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

##### 검증 코드
기존의 if/ else 로 테스트를 체크하던 부분에서 JUnit이 제공해주는 assertThat이라는 스태틱 메서드를 이용한다. assertThat()은 첫 번째 파라미터의 값을 뒤에 나오는 매처matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is() 는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.

### 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다. 대부분의 자바 IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있어서 더욱 편리하게 JUnit 테스트를 만들고 활용할 수 있게 해준다.

##### JUnit 테스트 실행 방법
자바의 대표적인 IDE 이클립스에서는 run -> runAs -> JUnit을 실행하면 @Test 어노테이션이 있는 메서드를 테스트한다. scope는 클래스에서 실행하면 클래스, 패키지에서 실행 시 패키지의 모든 테스트 메서드가 실행된다. JUnitCore.main으로 실행하는 것보다 훨씬 편리하다. 단축키로는 Alt+Shift+X->T를 순서대로 누르면 바로 실행된다.

##### 테스트 결과의 일관성
반복적인 테스트를 수행했을 떄 성공과 실패의 경우가 모두 존재한다면 좋은 테스트라고 할 수 없다. DB 서버가 다운됐다거나 네트워크에 장애가 생겨서 DB에 접근하지 못한다는 그런 특별한 예외를 제외하곤 테스트는 몇번을 반복해도 동일한 값을 반환해야 한다. 또한 주의사항으로 JUnit의 경우 특정한 테스트 메서드의 실행순서를 보장해주지 않는다. 실행순서에 따른 테스트의 결과값이 다르다면 잘못된 테스트 케이스를 작성한 것이다. 테스트 코드는 항상 독립적으로 동일한 결과를 낼 수 있도록 해야한다.

##### 포괄적인 테스트
간단한 코드의 경우 어느정도 경험이 있는 개발자라면 테스트코드를 작성하지않고도 문제가 생기지 않다는 것을 확인할 것이다. 하지만 이런 간단한 코드에서도 특별한 상황에 엉뚱한 결과값을 가져올 수 있다. 이럴 때 테스트코드를 작성하지 않았다면 원인을 찾기 힘들어서 고생하게 될 지도 모른다. 그리고 개발자들이 자주하는 실수 중 하나가 성공테스트만 진행하는 것이다. 대다수의 개발자들이 성공테스트를 확인 후 빠르게 다음 개발을 하러가는 경우가 많기 때문에 실패케이스부터 만드는 것을 추천한다. 또한 테스트의 경우 경계값 테스트를 통해 최대값 실패, 최소값 실패, 최대값 성공, 최소값 성공 등 경계값에 따른 테스트를 진행하는 것이 효율적이다.

##### 기능설계를 위한 테스트
|      |단계	       |내용				 |코드|
|---|------|---|---|
|조건|어떤 조건을 가지고|가져올 사용자 정보가 존재하지 않는 경우에|dao.deleteAll();  assertThat(dao.getCount(), is(0));|
|행위|무엇을 할 때         |존재하지 않는 id로 get()을 실행하면	|get("unknown_id");|
|결과|어떤 결과가 나온다|특별한 예외가 던져진다. 		|@Test(expected = EmptyResultDataAccessException.class)|

이렇게 비교해보면 이 테스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다. 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수도 있다.

##### 테스트 주도 개발
TDD : 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이다. "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다." 는 것이 TDD의 기본원칙이다.
TDD를 하지않고 개발을 하다보면 테스트케이스를 작성하지 않거나, 성의없는 테스트케이스로 인한 정확한 테스트 결과가 나오지 않을 수도 있다. TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다. 개발한 코드의 오류는 빨리 발견할수록 좋다. 빨리발견하면 쉽게 대응이 가능하다.

##### JUnit Framework 동작순서
1. 테스트 클래스에서 @Test가 붙은 public 이고 void형이며 파라미터가 없는 테스트 메서드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메서드가 있다면 실행한다.
4. @Test가 붙은 메서드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메서드가 있다면 실행한다.
6. 나머지 테스트 메서드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

* 테스트 오브젝트는 하나의 테스트 메서드에서만 사용하고 새로운 테스트 어노테이션이 존재할 경우 새롭게 오브젝트를 생성한다. 하나의 오브젝트만 생성하여 메모리를 절약하는 것보다 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 테스트 어노테이션 당 테스트 오브젝트를 생성하는 것이다.

##### 픽스처
테스트를 수행하는 데 필요한 정보나 오브젝트를 말한다. 일반적으로 픽스처는 여러 메서드에서 사용하기 때문에 @Before 메서드에서 인스턴스 변수로 생성해두면 편리하다.

##### ApplicationContext
UserDaoTest에서 테스트를 진행하기 위해 @Before에서 ApplicationContext를 생성 후 초기화 해주었다. 지금이야 테스트가 3개밖에 없어서 문제가 없지만 테스트가 많아지면 문제가 발생한다. 애플리케이션 컨텍스트는 생성할 때마다 모든 싱글톤 빈 오브젝트를 초기화한다. 어떤 빈 오브젝트는 생성될 때 자체적인 초기화 작업을 진행해서 제법 많은 시간이 필요하다. 또한 애플리케이션 컨텍스트가 초기화 될 때 어떤 빈은 독자적으로 많은 리소르르 할당하거나 독립적인 스레드를 띄우기도 한다는 점이다. 테스트코드는 항상 독립적으로 매번 새로운 오브젝트를 사용하는 것이 원칙이지만 이러한 문제를 해결하기 위해서는 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 원칙을 벗어날 수 있는 이유는 애플리케이션 컨텍스트는 초기화된 후에는 내부의 상태가 바뀌는 일은 거의 없다. 빈은 싱글톤으로 만들엇기 때문에 상태를 갖지 않는다. 이럴 때 사용하는 어노테이션은 @BeforeClass 이다. 이 어노테이션은 스태틱 메서드를 지원한다.

##### 스프링 테스트컨텍스트 프레임워크 적용
위의 설명처럼 복잡하게 ApplicationContext를 생성하지 않아도 스프링 프레임워크에서 지원하는 @ContextConfiguration 어노테이션을 사용하여 컨텍스트 생성자를 통한 @Autowired로 ApplicationContext 빈을 사용할 수 있다. ( 의존성 주입 )

##### 테스트 클래스의 컨텍스트 공유
모든 테스트 클래스의 컨텍스트 생성 위치를 동일하게 작성하게 되면 모든 테스트 클래스의 컨텍스트는 하나만 생성되어 모든 테스트 클래스에 사용하게 된다. 이럴경우 처음 컨텍스트를 생성하고 이후에는 생성된 컨텍스트를 의존성 주입하기 때문에 테스트 속도가 향상된다.

##### @Autowired, @Inject, @Resource
의존성 주입에 사용하는 어노테이션으로 변수타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 빈을 주입해준다. 그렇게 되면 NullPointException이 발생하지 않게 된다.

Autowired : 타입 -> 이름 [ 타입이 같은 Bean을 먼저 찾는다. 같은 타입이 여러개 존재할 경우 예외가 발생하기 때문에 @Qualifier 어노테이션을 추가하여 이름을 지정해준다. ]
Inject : 타입 -> 이름 [ 타입이 같은 Bean을 먼저 찾는다. 같은 타입이 여러개 존재할 경우 예외가 발생하기 때문에 @Qualifier 어노테이션을 추가하여 이름을 지정해준다. ]
Resource : 이름 -> 타입 [ 인스턴스 변수의 이름과 Bean ID를 매핑시켜 먼저 찾는 방식이다. ]

##### @DirtiesContext 
이 어노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 이 어노테이션이 붙으면 생성된 애플리케이션 컨텍스트를 공유를 허용하지 않는다. 그리고 이 어노테이션은 기존에 생성된 애플리케이션컨텍스트를 공유하지 않기 때문에 테스트 클래스의 오브젝트가 생성될 때마다 따로 설정한 애플리케이션 컨텍스트도 새로 생성된다. 이러한 문제를 해결하는 방안으로는 클래스에 어노테이션을 붙여서 테스트 클래스의 모든 테스트메서드가 적용되게 처리하는 것이 아닌 DB정보 변경이 필요한 메서드에 한해서 어노테이션을 붙여준다면 메서드 단위로 애플리케이션 컨텍스트를 관리할 수 있다.

##### 침투적 기술과 비침투적 기술
침투적 기술 (invasive) : 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 말한다. 사용 시 애플리케이션 코드가 해당 기술에 종속되는 결과를 가져온다.

비침투적 기술 (noninvasive) : 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다. 따라서 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해준다. 스프링은 이런 비침투적인 기술의 대표적인 예다.

##### DI를 이용한 테스트 선택 방법
항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자. (TDD에서 하듯 객체 생성하여 객체 내 메서드를 테스트하는 방법.) 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다.
다음은 여러 오브젝트가 복잡한 의존관계를 가지고 있을 경우 DI 방식의 테스트를 이용하면 편리하다.

##### 학습 테스트
보통의 테스트 코드란 자신이 구현 할 또는 구현된 코드를 테스트 하기 위해 작성하는 코드이다. 하지만 학습 테스트란 타인의 작성한 코드를 공부하기 위한 목적으로 작성하는 테스트 코드이다. 이런 테스트코드를 작성하는 이유는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증하는 것이 목적이다.

장점
- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 대한 좋은 훈련이 된다.
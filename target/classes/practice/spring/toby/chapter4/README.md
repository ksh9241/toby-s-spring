# 예외
잘못된 예외처리 코드 때문에 찾기 힘든 버그를 낳을 수도 있고, 생각하지 않았던 예외상황이 발생했을 때 상상 이상으로 난처해질 수도 있다.

### 초 난감 예외처리
#####예외 블랙홀 

```JAVA
try {
  ...
} catch (Exception e) { // 예외를 잡고 아무것도 하지 않는다.
   System.out.println(e);
   e.printStackTrace();  // 콘솔에 예외를 출력하는 두 개의 코드 역시 문제가 많다.
}
```
예외가 발생하면 try/catch를 사용하여 잡아내는 것까지는 좋은데 아무것도 하지않고 별 문제 없는 것처럼 넘어가 버리는 건 정말 위험한 일이다. 원치 않는 예외가 발생한 것보다 훨씬 더 나쁜 일이다. 왜냐하면 저렇게 처리하면 예외는 나오지않는데 프로그램은 계속 실행되기 때문이다. 예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다. 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다. 조취를 취할 방법을 모르겠다면, 메서드에 throws Exception을 선언해서 메서드 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가해버려라.

##### 무책임한 throws
가끔 보면 호출하는 모든 메서드에 throws Exception을 통해 계속 예외처리를 던져버리는 경우가 있다.  이러한 소스에도 심각한 문제점이 있다. 결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 없는 기회를 박탈당한다. 이러한 코드도 매우 안 좋은 예외 처리 방법이다. 위 두 가지 나쁜 습관은 어떤 경우에도 용납하지 않아야 한다.

##### 예외의 종류와 특징
자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.
- Error
첫째는 java.lang.Error 클래스의 서브 클래스들이다. 주로 자바 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고하면 안된다. OutOfMemoryError이나 ThreadDeath 같은 에러는 catch 블록에서 잡아봤자 아무런 대응 방법이 없기 때문이다. 따라서 애플리케이션에서는 이러한 에러에 대한 처리는 신경쓰지 않아도 된다.

- Exception과 체크 예외
java.lang.Exception 클래스와 그 서브 클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다. Exception 클래스는 체크 예외와 언체크 예외로 구분된다. 체크예외의 경우 Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들이고 언체크 예외는 RuntimeException 클래스를 상속한 예외이다.
- Exception
	- checked Exception
		- Exception 클래스의 서브클래스 && RuntimeException 클래스 상속 X
	- unchecked Exception
		- RuntimeException 클래스의 서브클래스

체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

- RuntimeException과 언체크/런타임 예외
RuntimeException을 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 오브젝트를 할당하지 않은 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NPE이나, 허용되지 않는 값을 사용해서 메서드를 호출할 때 발생하는 IllegalArgumentException 등이 있다. 코드에서 미리 조건을 체크하도록 주의 깊게 만든다면 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외다. 예상하지 못했던 예외상황에서 발생하기 때문에 굳이 try/catch나 throws를 사용하지 않아도 되도록 만든 것이다.

##### 예외 처리방법
- 예외 복구
예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다. 가령 네트워크가 불안해서 원격 DB 서버에 접속하다 실패해서 SQLException이 발생할 수도 있다. 이런경우 일정시간 기다린다던가, 다른 네트워크를 잡는 등 예외상황으로부터 복구를 시도할 수 있다.

- 예외 처리 회피
예외 처리를 자신이 담당하지 않고 호출한 메서드로 던져버리는 것이다. throws를 통한 예외 발생 시 던지거나 catch 블록 내 throw를 통한 발생된 예외를 던지는 것이다. JdbcContext나 JdbcTemplate를 사용하다가 ResultSet 혹은 PreparedStatement를 사용하다 SQLException이 발생하면 자신이 처리하지 않고 템플릿으로 던져버린다. 콜백 오브젝트의 메서드는 모두 throws SQLException이 붙어있다. 예외를 처리하는 일은 콜백 오브젝트의 역할이 아니라고 보기 때문이다. 하지만 콜백과 템플릿처럼 긴밀한 관계가 아닌 상황에서 자신의 코드에서 발생한 예외를 그냥 던지는 것은 무책임한 책임회피링 수 있다. 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.

- 예외전환
예외 회피랑 비슷하게 예외를 메서드 밖으로 던지지만 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다. 예외전환은 보통 두 가지 목적으로 사용된다.
1. 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우, 그 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서다.
예시로 새로운 사용자를 등록하려 시도했을 때 동일한 데이터가 있어서 SQLException을 그대로 밖으로 던져버리면 DAO를 이용해 사용자를 추가하려고 한 서비스 계층 등에서는 왜 SQLException이 발생했는지 쉽게 알 방법이 없다. 이럴 땐 DAO에서 예외를 해석해서 DuplicateUserIdException 같은 예외로 바꿔서 던져주는 게 좋다.
```JAVA
catch (SQLException e) {
	if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) throw DuplicateUserIdException(e); // 중첩예외
	else throw e;
}
```

일반적으로 체크 예외를 계속 throws를 사용해 넘기는 건 무의미하다. 메서드 선언이 지저분해지고 아무런 장점이 없다. 이런경우 해결할 수 없다면 빠르게 RuntimeException으로 포장해 던지게 해서 다른 계층의 메서드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 처리해야 한다.

##### 런타임 예외의 보편화
자바 초기부터 있었던 JDK의 API와 달리 최근에 등장하는 표준 스펙 또는 오픈소스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 정의하는 것이 일반화되고 있다. 예전에는 복구 가능성이 조금이라도 있다면 체크예외로 만들었지만 지금은 항상 복구할 수 있는 예외가 아니라면 언체크 예외로 만드는 경향이 있다. 단 런타임 예외를 사용할 경우 사용에 더 주의를 기울일 필요도 있다. 컴파일러가 강제하지 않으므로 신경 쓰지 않으면 예외 상황을 충분히 고려하지 않을 수도 있기 때문이다.

##### 애플리케이션 예외
시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch해서 무엇인가 조치를 취하도록 요구하는 예외를 애플리케이션 예외라고 한다.
만약 출금 서비스를 만든다고 가정해보자면 잔고를 확인하지 않고 요청하는 금액을 무차별적으로 출금해주는 서비스는 없을 것이다. 이럴 때 DB에 출금요청 금액만큼 출금 후 잔액 부족같은 상황을 예외로 잡아서 요청한 메서드에 throw하게되면 금전적인 문제의 위험이 줄어든다. 이러한 상황은 런타임 예외로 만들어두는 것보다 필수로 체크해야하는 체크 예외로 만들어두느 ㄴ것이 안전하다.
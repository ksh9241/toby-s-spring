# 1장. IoC 컨테이너와 DI

### IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트
스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고 부르기도 한다. 오브젝트 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 떄는 컨테이너를 빈 팩토리라고 한다.

#### 1.1.1 IoC 컨테이너를 이용해 애플리케이션 만들기

##### POJO 클래스
각각의 POJO는 특정 기술과 스펙에서 독립적일뿐더러 의존관계에 있는 다른 POJO와 느슨한 결합을 갖도록 만들어야 한다.

##### 설정 메타정보
스프링의 설정 메타정보는 BeanDefinition 인터페이스로 표현되는 순수한 추상 정보다. 즉 애플리케이션 컨텍스트는 바로 이 BeanDefinition으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI 작업을 수행한다.
원본의 포맷과 구조, 자료의 특성에 맞게 읽어와 BeanDefinition 오브젝트로 변환해주는 BeanDefinitionReader가 있으면 된다.

- 빈 메타정보
	- 빈 아이디, 이름, 별칭 : 빈 오브젝트를 구분할 수 있는 식별자
	- 클래스 또는 클래스 이름 : 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보
	- 스코프 : 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
	- 프로퍼티 값 또는 참조 : DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
	- 생성자 파라미터 값 또는 참조 : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
	- 지연로딩 여부, 우선 빈 여부, 자동와이어링 여부, 부모 빈 정보, 빈팩토리 이름 등

결국 스프링 애플리케이션이란 POJO 클래스와 설정 메타정보를 이용해 IoC컨테이너가 만들어주는 오브젝트 조합이다.


#### 1.1.2 IoC컨테이너의 종류와 사용방법
이미 스프링에는 다양한 용도로 쓸 수 있는 십여 개의 ApplicationContext 구현 클래스가 존재한다. 직접 코드를 통해 ApplicationContext 오브젝트를 생성하는 경우는 거의 없다. 스프링에서 제공하는 ApplicationContext 구현 클래스 종류에 대해 살펴보자.

##### StaticApplicationContext
BeanDefinition 오브젝트를 직접 만들고, 코드를 통해 IoC 컨테이너에 등록하는 방법을 사용해봤다. 이 때 사용하는 컨테이너는 StaticApplicationContext다. StaticApplicationContext는 코드를 통해 빈 메타정보를 등록하기 위해 사용한다.
스프링의 기능에 대한 학습테스트를 제외하면 실제로 사용하지 않는다. 스태틱 애플리케이션 컨텍스트는 실전에서는 사용하면 안 된다. ( 이유에 대해 찾아봤지만 안나와서 코드를 봐보니 기본생성자가 Null로 되어있어서 그런가?? 추후 더 찾아볼 예정 )

##### GenericApplicationContext
GenericApplicationContext는 가장 일반적인 애플리케이션 구현 클래스이다. 실전에서 사용될 수 있는 모든 기능을 갖추고 있으며 컨테이너의 주요 기능을 DI를 통해 확장할 수 있도록 설계되었다. StaticApplicationContext 와는 달리 XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리더를 통해 읽어들여서 메타정보로 전환해서 사용한다. 스프링은 XML 말고도 프로퍼티 파일에서 빈 설정 메타정보를 가져오는 PropertiesBeanDefinitionReader도 제공한다.
JUnit 테스트 내에서 사용할 수 있는 애플리케이션 컨텍스트를 자동으로 만들어 주는데 이 컨텍스트가 바로 GenericApplicationContext다.

##### GenericXmlApplicationContext
GenericXmlApplicationContext 는 XmlBeanDefinitionReader를 내장하고 있기 떄문에 따로 만들지 않고 XML파일을 읽어서 refresh를 통해 초기화하는 것 까지 한 줄로 끝낼 수 있다.

##### WebApplicationContext
웹 환경에서 main() 메서드 대신 서블릿 컨테이너가 브라우저로의 오는 HTTP 요청을 받아서 해당 요청에 매핑되어 있는 서블릿을 실행해주는 방식으로 동작한다. 서블릿이 일종의 main() 메서드와 같은 역할을 하는 셈이다.
서블릿 컨테이너는 브라우저와 같은 클라이언트로부터 들어오는 요청을 받아서 서블릿을 동작시켜주는 일을 맡는다. 다행히도 스프링은 웹 환경에서 애플리케이션 컨텍스트를 생성하고 설정 메타 정보로 초기화해주고, 클라이언트로부터 들어오는 요청마다 적절한 빈을 찾아서 이를 실행해주는 기능을 가진 DispatcherServlet이라는 이름의 서블릿을 제공한다. 일단 스프링 IoC 컨테이너는 WebApplicationContext 인터페이스를 구현한 것임을 기억하자.

#### 1.1.3 IoC 컨테이너 계층구조
IoC 컨테이너는 애플리케이션마다 하나씩이면 충분하다. 빈의 개수가 많아져서 설정파일이 커지는게 문제라면 쪼개서 만들고 하나의 애플리케이션 컨텍스트가 어려 개의 설정파일을 사용하게 하면 그만이다.
하지만 한 개 이상의 IoC 컨테이너를 만들어두고 사용해야 할 때가 있는데 바로 트리 모양의 계층 구조이다.

##### 부모 컨텍스트를 이용한 계층구조 효과
계층구조 안에 모든 컨텍스트는 각자 독립적인 설정정보를 가지고 빈 오브젝트를 만들고 관리한다. 하지만 DI를 위해 빈을 찾을 때는 자신의 빈부터 부모 컨텍스트의 빈까지 모두 검색한다. 다만 하위 컨텍스트에서는 빈을 검색하지 않는다. 그런 의미에서 같은 레벨에 있는 형제 컨텍스트의 빈도 찾을 수 없다. 때문에 자신이 만든 스프링 애플리케이션이 어떻게 컨텍스트가 만들어지고 어느 것이 루트 컨텍스트이고, 어느 것이 그 자식 컨텍스트인지는 분명하게 알아야 한다.

#### 1.1.4 웹 애플리케이션의 IoC 컨테이너 구성
애플리케이션에서 IoC 컨테이너를 사용하는 방법은 크게 세 가지로 구분된다. 두 가지는 웹 모듈 안에 컨테이너를 두는 것이고, 하나는 엔터프라이즈 애플리케이션 레벨에 두는 방법이다.

많은 웹 요청을 한 번에 받을 수 있는 대표 서블릿을 등록해두고, 공통적인 선행 작업을 수행하게 한 후에 각 요청의 기능을 담당하는 핸들러라고 불리는 클래스를 호출하는 방식으로 개발한다.

##### 웹 애플리케이션의 컨텍스트 계층구조
웹 애플리케이션 컨텍스트에 등록되는 컨테이너는 루트 웹 애플리케이션 컨텍스트라고 불린다. 일반적으로 전체 계층구조 내에서 가장 최상단에 위치한 루트 컨텍스트가 되기 떄문이다.
그런데 여러 개의 자식 컨텍스트를 두고 공통적인 빈을 부모 컨텍스트로 뽑아내서 공유하려는게 아니라면 왜 이렇게 계층구조로 만들까?? 이유는 전체 애플리케이션에서 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위해서다.
데이터 엑세스 계층, 서비스 계층은 스프링 기술을 사용하고 스프링 빈으로 만들지만 웹을 담당하는 프레젠테이션 계층은 스프링 외의 기술을 사용하는 경우도 종종 있기 때문이다.

스프링은 웹 애플리케이션마다 하나씩 존재하는 서블릿 컨테이너를 통해 루트 애플리케이션 컨텍스트에 접근할 수 있는 방법을 제공한다.

- WebApplicationContextUtils.getWebApplicationContext(ServletContext sc) : DispatcherServlet이나 WebApplicationContext에 접근할 수 있는 static 메서드를 제공한다.

ServletContext는 웹 애플리케이션마다 하나씩 만들어지는 것으로, 서블릿의 런타임 환경정보를 담고있다.

##### 웹 애플리케이션 컨텍스트 구성 방법
1. 컨텍스트 계층구조 만들기
2. 컨텍스트를 하나만 사용하기

- 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조
	- 가장 많이 사용되는 기본적인 구성방법이다. 스프링 웹 기술을 사용하는 경우 웹 관련 빈들은 서블릿의 컨텍스트에 두고 나머지는 루트 애플리케이션 컨텍스트에 등록한다.

- 루트 애플리케이션 컨텍스트 단일구조
	- 스프링 웹 기술을 사용하지 않고 서드파티 웹 프레임워크나 서비스 엔진만을 사용해서 프레젠테이션 계층을 만든다면 스프링 서블릿을 둘 이유가 없다.

- 서블릿 컨텍스트 단일 구조
	- 스프링 웹 기술을 사용하면서 스프링 외의 프레임워크나 서비스 엔진에서 스프링 빈을 이용할 생각이 아니라면 루트 애플리케이션 컨텍스트를 생략할 수도 있다.


##### 루트 애플리케이션 컨텍스트 등록
웹 애플리케이션 레벨에 만들어지는 루트 웹 애플리케이션 컨텍스트를 등록하는 가장 간단한 방법은 서블릿의 이벤트 리스너를 이용하는 것이다. 웹 애플리케이션 전체에 적용 가능한 DB 연결 기능이나 로깅 같은 서비스를 만드는 데 유용하게 쓰인다. 스프링은 이러한 기능을 가진 리스너인 ContextLoaderListener를 제공한다.

```JAVA
/** 
ContextLoaderListener 등록 방법 : web.xml에 리스너 선언
기능 : 웹 애플리케이션이 시작할 때 자동으로 루트 애플리케이션 컨텍스트 생성 후 초기화

Default
애플리케이션 컨텍스트 클래스 : XmlWebApplicationContext
XML 설정파일 위치 : /WEB-INF/applicationContext.xml
*/

<listener>
	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

- contextConfigLocation : 디폴트 XML 설정파일 위치를 바꿀 수 있다.
- contextClass : 디폴트 애플리케이션컨텍스트 클래스를 변경할 수 있다.

##### 서블릿 애플리케이션 컨텍스트 등록
스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿은 DispatcherServlet이다. 이름에서 알 수 있듯이 web.xml에 등록해서 사용할 수 있는 평범한 서블릿이다. 각 DispatcherServlet은 서블릿이 초기화 될 때 자신만의 컨텍스트를 생성하고 초기화한다.

### 1.2 IoC/DI를 위한 빈 설정 메타정보 작성
IoC 컨테이너의 가장 기본적인 역할은 코드를 대신해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리하는 것이다. POJO로 만들어진 애플리케이션 클래스와 서비스 오브젝트들이 그 대상이다.
빈을 만들기 위한 설정 메타정보는 파일이나 어노테이션 같은 리소스로부터 전용 리더를 통해 얽혀서 BeanDefinition 타입의 오브젝트로 변환된다. BeanDefinition에 어떠한 방식으로든 빈 생성 정보만 담겨있다면 IoC 컨테이너가 빈을 읽어서 처리할 수 있다.

#### 1.2.1 빈 설정 메타정보
BeanDefinition은 여러 개의 빈을 만드는 데 재사용될 수 있다. 설정 메타정보가 같지만 이름이 다른 여러 개의 빈 오브젝트를 만들 수 있기 때문이다.
따라서 BeanDefinition 에는 빈의 이름이나 아이디를 나타내는 정보를 포함하지 않는다. 대신 IoC 컨테이너에 이 BeanDefinition 정보가 등록될 때 이름을 부여해줄 수 있다.

#### 1.2.2 빈 등록 방법
빈 등록 방법은 메타정보를 작성해서 컨테이너에게 건네주면 된다. 보통 XML문서, 프로퍼티 파일, 소스코드 어노테이션과 같은 외부 리소스로 빈 메타정보를 작성하고 이를 적절한 리더나 변환기를 통해 애플리케이션 컨텍스트가 사용할 수 있는 정보로 변환해주는 방법을 사용한다.

스프링에서 자주사용되는 빈의 등록방법 5가지

- XML :<Bean>태그
- XML : 네임스페이스와 전용 태그
- 자동인식을 이용한 빈 등록 : 스테레오타입 어노테이션과 빈 스캐너
- XML을 이용한 빈 스캐너 등록
- 빈 스캐너를 내장한 애플리케이션 컨텍스트 사용


##### 자바 코드에 의한 빈 등록 : @Configuration 클래스의 @Bean 메서드
자바코드를 이용한 빈 등록에 사용되는 클래스는 그저 평범한 자바 코드처럼 동작하지 않는다는 사실을 알아야 한다. @Bean이 붙은 메서드는 new를 통한 여러번 생성을 시켜도 싱글톤이 디폴트 값이기 때문에 최초 한번만 빈으로 생성된다.  DI를 통해 다른 여러 빈에 참조되든, getBean() 메서드에 의해 가져오든 상관없이 한 개의 오브젝트만 생성이 되고 더 이상 새로운 오브젝트가 만들어지지 않도록 특별한 방법으로 @Bean 메서드를 조작해둔다.
@Configuration 과 @Bean을 사용하는 클래스는 순수한 오브젝트 팩토리 클래스라기보다는 자바 코드로 표현하는 메타정보라고 이해하는 것이 좋다.

자바코드에 의한 설정이 XML과 같은 외부 설정 파일을 이용하는 것보다 유용한 점

- 컴파일러나 IDE를 통한 타입 검증이 가능하다.
	- XML은 런타임 시 예외가 발생해야 오류 검증이 가능한데 자바코드는 컴파일 시 오류를 확인할 수 있다.

- 자동완성과 같은 IDE 지원 기능을 최대한 이용할 수 있다.
	- XML과 다르게 자동완성의 기능을 이용하여 오타도 줄이면서 빠르게 만들 수 있다.

- 이해하기 쉽다.
	- 평범한 자바코드가 <Bean>태그보다 더 친숙하다.

- 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용할 수 있다.


##### 자바 코드에 의한 빈 등록 : 일반 빈 클래스의 @Bean 메서드
@Configuration 어노테이션이 붙은 클래스가 아닌 일반 POJO클래스에서도 @Bean을 사용할 수 있다. 다만 이때는 POJO 클래스에서 빈을 생성하기 때문에 싱글톤 빈으로 사용되지 않는다. 그렇기 때문에 일반 클래스에서 @Bean 사용 할 때는 DI 코드를 주의해서 작성해야 한다.

@Bean 메서드가 정의된 클래스 밖에서 사용할 수 없게 scope를 private으로 선언한 뒤 클래스 내부에서 DI를 통해서 참조하도록 한다.


##### 빈 등록 메타정보 구성 전략

- XML 단독 사용 : 모든 빈을 명시적으로 XML에 등록하는 방법
	- 모든 빈을 XML에서 확인할 수 있는 장점
	- 빈이 많아지면 XML관리가 번거로울 수 있다는 단점

- XML과 빈 스캐닝의 혼용 : XML과 빈 스캐너에 의한 자동인식 방법을 함께 사용하는 방법
	- 애플리케이션 3계층의 핵심로직을 빈 스캐닝에 의한 자동인식 대상으로 처리
	- 불편한 기술서비스, 기반 서비스, 컨테이너 설정 등의 빈은 XML을 사용하여 처리
	- 스캔 대상이 되는 클래스의 패키지를 지정해줘야 한다. (context:component-scan)

- XML 없이 빈 스캐닝 단독 사용 : 모든 빈의 등록을 XML 없이 자동스캔만으로 가져가는 방법
	- 스프링 3.0에서 처음 가능하다.
	- 루트컨텍스트와 서블릿 컨텍스트 모두 contextClass 파라미터를 추가해 AnnotationConfigWebApplicationContext로 컨텍스트 클래스를 변경해줘야한다.
	- contextLocations 파라미터에는 스캔 대상 패키지를 넣어줘야 한다.
	- 장점으로는 빈의 모든 정보가 자바코드에 담겨 있으므로 타입에 안전한 방식으로 작성 가능
	- 단점은 스키마에 정의된 전용 태그를 사용할 수 없다. (aop, tx 등)


#### 1.2.3 빈 의존관계 설정 방법
총 8가지의 빈 의존관계 주입 방법이 존재한다.

##### XML: <property>, <constructor-arg>
<bean>을 이용해 빈을 등록했다면 프로퍼티와 생성자 두 가지 방식으로 DI를 지정할 수 있다. 프로퍼티는 수정자 메서드를 사용하고, 생성자는 빈 클래스의 생성자를 이용하는 방법이다.

- <property>: 수정자 주입

수정자를 통한 의존관계의 빈을 주입하려면 <property> 태그를 사용할 수 있다. DI의 가장 대표적인 방법이다.
XML의 <property> 에는 해당 프로퍼티의 타입정보가 나타나지 않는다. 따라서 주입 대상 프로퍼티와 주입될 빈 또는 값의 타입이 호환되는지 주의를 기울여서 작성해야 한다.

```JAVA
<property name="name" value="Spring" />
<property name="age" value="30" />
<property name="myClass" value="java.lang.String" />
```

- <constructor-arg>: 생성자 주입

constructor-arg는 생성자를 통한 빈 또는 값의 주입에 사용된다. 생성자의 파라미터를 이용하기 때문에 한 번에 여러 개의 오브젝트를 주입할 수 있다.
수정자 메서드처럼 간단히 이름을 이용하는 대신 파라미터의 순서나 타입을 명시하는 방법이 필요하다.

```JAVA
<constructor-arg index="0" value="Spring" />
<constructor-arg type="package.depth1.Printer" ref="printer" />
```

##### XML : 자동와이어링
자동와이어링은 명시적으로 프로퍼티나 생성자 파라미터를 지정하지 않고 미리 정해진 규칙을 이용해 자동으로 DI 설정을 컨테이너가 추가하도록 만드는 것이다.

- byName: 빈 이름 자동와이어링

autowire="byName" 옵션으로 해당 클래스의 프로퍼티 이름과 동일한 빈을 찾아서 자동으로 프로퍼티로 등록해준다.

```JAVA
<bean id="hello" class="...Hello" autowire="byName">
	<property name="name" value="Spring" />
	<!-- autowire="byName" 옵션을 주어 printer빈의 id와 Hello 빈의 printer인스턴스명을 보고 DI를 하여 생략하였다. -->
</bean>

<bean id="printer" class="...StringPrinter" />
```

- byType: 타입에 의한 자동와이어링

이전에 만들어진 클래스를 재사용하거나 규모가 큰 프로젝트라 모든 개발자가 명명규칙을 정확하게 부여하기가 어렵다면 이름 대신 타입에 의한 자동와이어링을 사용할 수 있다.
autowire="byType"을 옵션에 <bean>에 넣어주거나 default-autowire=byType"을 <beans>에 넣어주면 된다.
단점으로는 타입이 같은 빈이 두 개 이상 존재하는 경우에는 적용되지 못한다.

##### XML : 네임스페이스와 전용 태그
스키마를 정의해서 사용하는 전용 태그의 의존관계 지정은 단순하지 않다. 태그 하나당 몇 개의 빈이 만들어지는 지 각 빈의 이름은 무엇인지가 명확하지 않기 때문이다.
규칙은 아니지만 관례적으로 전용 태그에 의해 만들어지는 빈을 다른 빈이 참조할 경우에는 id 어트리뷰트를 사용해 빈의 아이디를 지정한다. 그래서 다른 빈의 DI할 때 ref값으로 넣어줄 수 있다.
상당수의 전용 태그는 ID조차 선언하지 않는 경우가 많다. 대부분 컨테이너가 참조하는 설정정보로만 사용되기 때문이다.

##### 어노테이션 : @Resource
- 수정자 메서드

수정자 setter는 가장 대표적인 DI 방법이다.
@Resource와 같은 어노테이션으로 된 의존관계 정보를 이용해 DI가 이뤄지게 하려면 다음 세 가지 방법 중 하나를 선택해야 한다.

1. XML의 <context:annotation-config />

@Resource와 같은 어노테이션 의존관계를 읽어서 메타정보를 추가해주는 기능을 가진 빈 후처리기를 등록해주는 전용 태그다.


2. XML의 <context:component-scan />

빈 스캐닝을 통한 빈 등록 방법을 지정하는 것


3. AnnotationConfigApplicationContext 또는 AnnotationConfigWebApplicationContext

빈 스캐너와 어노테이션 의존관계 정보를 읽는 후처리기를 내장한 애플리케이션컨텍스트를 사용하는 것이다.


- 필드

@Resource는 필드에도 붙을 수 있다. 수정자가 없어도 상관없다. 필드의 접근자는 public이 아니어도 상관없다. 프로퍼티에 대한 수정자가 없다면 코드가 깔끔해지긴하지만 컨테이너 밖에서 수동으로 DI할 경우 불편하다. 단위테스트가 필요한 클래스라면 수정자 없는 필드 주입을 사용하는 건 별로 바람직하지 않다.
반면 컨테이너를 이용하는 통합 테스트를 주로 하는 DAO에서는 수정자 없이 필드 주입만을 사용해도 별 문제가 되지 않는다.

XML의 자동와이어링은 각 프로퍼티에 주입할 만한 후보 빈이 없을 경우에 무시하고 넘어간다. 하지만 @Resource같은 경우 반드시 참조할 빈이 존재해야 한다. 만약 DI할 빈을 찾을 수 없다면 예외가 발생한다.
참조할 빈의 이름을 이용하여 빈을 찾는다. 하지만 이름을 통한 빈을 찾을 수 없을 경우 타입을 통해 한번 더 빈을 찾는다.


##### 어노테이션 :@Autowired/@Inject
어노테이션을 이용한 의존관계 설정 방법의 두 번째는 @Autowired와 @Inject를 이용하는 것이다.
스프링으로 개발한 POJO를 앞으로 다른 환경에서도 사용할 가능성이 있다면 @Inject와 DIJ에서 정의한 어노테이션을 사용하는 게 좋다.

- 수정자 메서드와 필드

@Resource와 비슷하지만 다른점은 이름이 아닌 타입을 기준으로 먼저 DI할 빈을 찾는다.


- 생성자

@Autowired는 @Resource와 다르게 생성자에도 부여할 수 있다. @Autowired는 단 하나의 생성자에만 사용할 수 있다는 제한이 있다.

- 일반 메서드

@Autowired는 수정자, 생성자 외의 일반 메서드에도 적용할 수 있다. 생성자 주입은 모든 프로퍼티를 DI해야 하고, 수정자 주입은 수정자메서드의 관리가 번거롭기 때문에 각각의 장단점이 존재한다.
그래서 등장한 것이 일반 메서드를 사용한 DI 방법이다. 생성자 주입과 딜리 오브젝트 생성 후에 차례로 호출이 가능하므로 여러 개를 만들어도 된다.

- 컬렉션과 배열

@Autowired를 이용하면 같은 타입의 빈이 하나 이상 존재할 때 그 빈들을 모두 DI받도록 할 수 있다. @Autowired의 대상이 되는 필드나 프로퍼티, 메서드의 파라미터를 컬렉션이나 배열로 선언하면 된다.
컬렉션과 배열을 단지 같은 타입의 빈이 여러 개 등록되는 경우에 충돌을 피하려는 목적으로 사용해서는 안 된다. 의도적인 목적을 가지고 사용해야 한다.

```JAVA
@Autowired
Collection<Printer> printers;

@Autowired
Printer[] printers;

@Autowired
Map<String, Printer> printerMap;
```

- @Qualifier

Qualifier는 타입 외의 정보를 추가해서 자동와이어링을 세밀하게 제어할 수 있는 보조적인 방법이다.
@Qualifier를 사용했을 때 한 가지 기능이 더 있다. @Qualifier("mainDB")로 설정했을 때 Qualifier 속성 값의 mainDB가 없다면 mainDB로 된 빈을 한번 더 확인한다. 이 방법은 혼란을 초래할 수 있어서 권장하진 않지만 예외를 발생시키지 않을 수도 있다.


##### @Autowired와 getBean(), 스프링 테스트
getBean("빈 이름") 은 기본적으로 Object 타입으로 리턴한다. 따라서 원하는 타입으로 캐스팅해야 한다. 특정 타입 빈이 하나만 존재한다면 @Autowired 처럼 이름 대신 타입을 이용해서 빈을 찾을 수 있다.


##### 자바코드에 의한 의존관계 설정
@Configuration 과 @Bean을 이용하여 자바코드로 빈을 등록하는 경우

- @Bean 메서드 호출

@Configuration 이 붙지 않은 클래스의 @Bean 메서드에서는 싱글톤으로 오브젝트가 관리되지 않기 때문에 사용하면 안된다는 사실을 주의해야 한다.

#### 1.2.4 프로퍼티 값 설정 방법
보통 싱글톤은 동시성 문제 때문에 필드 값을 함부로 수정하지 않는다. 대개는 상태가 없는 방식으로 만들기 때문에 필드에 있는 값은 읽기전용인 경우가 대부분이다.

##### 메타정보 종류에 따른 값 설정 방법
값을 넣는 방법도 빈 등록 방법과 마찬가지로 네 가지로 구분해서 볼 수 있다.

- XML : <property>와 전용 태그

ref 어트리뷰트를 이용해 다른 빈의 아이디를 지정한다. 만약 value 어트리뷰트를 사용한다면 런타임 시 주입할 값으로 인식한다.


- 어노테이션 : @Value

빈이 사용해야 할 단순한 값이나 오브젝트를 코드에 담지 않고 설정을 통해 런타임시 주입해주는 이유

빈 의존관계는 아니지만 어떤 값을 외부에서 주입해야 하는 용도는 두 가지가 있다.

1. 환경에 따라 매번 달라질 수 있는 값으로 대표적으로DataSource 타입의 빈에 제공하는 DriverClass, userName, password, URL이 있다.

2. 클래스의 필드에 초기값을 설정해두고 대개는 그 값을 사용하지만 특별한 경우 초기값 대신 다른 값을 지정하고 싶을 경우가 있다.

```JAVA
public class Test {
/**
 인스턴스 값 초기화와 @Value의 차이점
 @Value 어노테이션은 스프링 컨테이너가 참조하는 정보이지 그 자체로 클래스의 필드에 값을 넣어주는 기능이 있는 것은 아니다.
 따라서 테스트 코드와 같이 컨테이너 밖에서 사용된다면 @Value 어노테이션은 무시된다.
 @Value로 값을 설정해준다는 것은 자바 코드와 컨테이너가 런타임 시에 주입하는 정보를 분리하겠다는 의미이고, 외부로부터의 주입을 통한 초기화가 반드시 필요하다고 이해할 수 있다.
*/
	String a = "초기화";
	
	@Value("초기화")
	String b;

	// username속성이 정의된 database.properties 파일의 XML에서 지정해둬야 한다.
	@Value("${database.username}")
	String userName;
}
```

- 자바코드 : @Value

클래스 자체가 메타정보이기 때문에, 설정을 변경해야 할 때마다 코드를 수정하고 재컴파일하는 게 문제가 되지 않는다. 하지만 환경에 종속적인 정보는 역시 환경정보나 프로퍼티 파일에서 가져오는 것이 바람직하다.


##### PropertyEditor와 ConversionService
XML의 value 어트리뷰트나 @Value의 엘리먼트는 모두 텍스트 문자로 작성된다. 타입이 String이라면 상관없지만 그 외의 타입인 경우라면 타입을 변경하는 과정이 필요하다.

스프링은 두 가지 타입 변환 서비스를 제공한다. 디폴트로 사용되는 타입 변환기는 PropertyEditor라는 java.beans의 인터페이스를 구현한 것이다.

- 기본타입

스프링의 내장 프로퍼티 에디터가 변환을 지원하는 기본 타입이다.

[boolean, Boolean, byte, Byte, short, Short, int, Integer, long, Long, float, Float, double, Double, BigDecimal, BigInteger, char, Character, String]

int 같은 기본타입은 물론이고 Integer같은 오브젝트 타입도 함께  지원한다.


- 배열

값을 콤마로 구분해서 넣어주면 배열 형태로 변환한다.

@Value("1,2,3,4") int[] arr;

- 기타
	- charset : UTF-8, ISO-8895-1 과 같은 값을 Charset 타입으로 만들어준다.
	- Class : JDBC 드라이버 클래스를 선언할 때 자주 사용했던 타입이다.
	- Currency : ISO 4217 코드를 따르는 Currency타입으로 변환해준다.
	- File : File 타입으로 변환해준다. file:, classpath: 와 같은 접두어를 사용할 수 있다.
	- InputStream : InputStream 타입으로 변환해준다.
	- Pattern : Pattern 타입으로 변환해준다.
	- Resource : 스프링의 리소스 타입으로 변환해준다. 배열도 지원
	- Timezone : Timezone으로 변환해준다.
	- URI, URL : URI 또는 URL로 변환해준다.

각 타입의 프로퍼티 에디터를 찾는 방법은 타입 이름 뒤에 Editor를 붙여주면 된다.

스프링 3.0 부터는 PropertyEditor 대신 사용할 수 있는 ConversionService를 지원하기 시작했다.
ConversionService 느 스프링이 직접 제공하는 타입 변환 API다. 멀티스레드 환경에서 공유해 사용될 수 있다.


##### Null과 빈 문자열
스트링 타입에서 Null과 빈문자열은 비슷한 용도로 사용되기는 하지만 동일하지 않기 때문에 구분해서 사용해야 한다.
일반적인 경우에는 null을 명시적으로 선언할 필요는 없다.

```JAVA
<property name="name" value="" />
<property name="name"><null /><property/> <!-- 널 태그를 사용한다. -->
```

##### 프로퍼티 파일을 이용한 값 설정
XML에서 일부 설정정보를 별도의 파일로 분리해두면 유용할 때가 있다. 서버환경에 종속적인 정보가 있다면, 이를 애플리케이션의 구성정보에서 분리하기 위해서다. 변경되는 이유와 시점이 다르다면 분리하는 것이 객체지향 설계의 기본 원칙이다. 환경에 따라 자주 변경될 수 있는 내용은 프로퍼티 파일로 분리하는 것이 가장 깔끔하다.

또 한가지 장점은 @Value를 효과적으로 사용할 수 있다. @Value는 소스코드 안에 포함되는 어노테이션이어서 값이 변경되면 매번 새로 컴파일해야 한다. 하지만 프로퍼티 파일의 내용을 참조하게 하면 소스코드 수정 없이 @Value를 통해 프로퍼티에 값을 변경할 수 있다.

```JAVA
<!-- before -->
<bean id="test" class="...DataSource">
	<property name="driverClass" value="com.mysql.jdbc.Driver" />
</bean>

<!-- after -->
<bean id="test" class="...DataSource">
	<property name="driverClass" value="${db.driverClass}" />
</bean>

<!-- database.properties 파일 -->
db.driverClass=com.mysql.jdbc.Driver

/**
사용하기 위해서는 아래 태그를 추가해줘야 한다.
<context:property-placeholder location="classpath:database.properties" />
*/
```

이런 동작원리는 <context:property-placeholder> 태그에 의해 자동으로 등록되는 PropertyPlaceHolderConfigurer 빈이 담당한다. 이 빈은 빈 팩토리 후처리기다. 빈 팩토리 후처리기는 빈 설정 메타정보가 모두 준비됐을 때 빈 메타정보 자체를 조작하기 위해 사용된다.

- 능동변환 :SpEL

프로퍼티 대체위치를 설정해두고 빈 팩토리 후처리기에서 바꿔주기를 기다리는 수동적인 위의 방법과 달리 다른 빈 오브젝트에 직접 접근할 수 있는 표현식을 이용해 원하는 프로퍼티 값을 능동적으로 가져오는 방법이다.

```JAVA
<!-- before -->
<bean id="test" class="...DataSource">
	<property name="driverClass" value="com.mysql.jdbc.Driver" />
</bean>

<!-- after -->

<!-- 
빈 팩토리 후처리기 처럼 동작해서 처리하는 것이 아닌 단순 프로퍼티 파일의 내용을 담은 properties 타입 빈을 만들어 줄 뿐이다. 
properties 는 Map 인터페이스를 구현한 클래스이다.
-->
<util:properties id="dbprops" location="classpath:database.properties" /> 

<bean id="test" class="...DataSource">
	<property name="driverClass" value="#{dbprops['db.driverClass']}" />
</bean>

<!-- database.properties 파일 -->
db.driverClass=com.mysql.jdbc.Driver
```

#### 1.2.5 컨테이너가 자동등록하는 빈

##### ApplicationContext, BeanFactory
스프링에서는 컨테이너 자신을 빈으로 등록해두고 필요하면 일반 빈에서 DI 받아서 사용할 수 있다.

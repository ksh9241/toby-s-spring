# 템플릿
템플릿이란 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있는데 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

##### 리소스 반환과 close()
Connection과 PreparedStatement는 보통 풀(pool) 방식으로 운영된다. 미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할 때 이를 할당하고, 반환하면 다시 풀에 넣는 방식으로 운영된다. 요청이 매우 많은 서버환경에서는 매번 새로운 리소스를 생성하는 대신 풀에 미리 만들어둔 리소스를 돌려가며 사용하는 편이 훨씬 유리하다. 대신 사용한 리소스는 빠르게 반환해야 한다. 그렇지 않으면 풀에 있는 리소스가 고갈되고 결국 문제가 발생한다. close()는 사용된 리소스를 반환해주는 메서드이다.

##### 분리와 재사용을 위한 디자인 패턴 적용
DB커넥션 연결과 같이 Dao에서 지속적으로 사용하는 코드가 메서드 단위로 반복적인 호출이 일어난다. 중복코드를 처리하는 방법으로는 변하는 부분과 변하지 않는 부분을 찾아서 처리하면 된다.
예제로 chapter3의 UserDao 클래스에서 PreparedStatement 의 부분을 제외한 Connection, ResultSet 등의 부분은 변하지 않는다. 원래는 변하지 않는 부분의 코드를 메서드로 만드는 것이 낫지만 변하는 부분이 변하지 않는 부분 중간에 껴있기 때문에 변하는 부분을 메서드로 만들고 하나의 메서드에서 재사용하는 방법으로 리팩토링을 선택하였다.

##### 템플릿 메서드 패턴의 적용
기존에 makeStatement 메서드를 추상메서드로 만들어서 자식클래스에서 재정의한 후 변하지 않는 부분에서 클래스를 호출하여 사용한다. 하지만 장점보다 단점이 더 많이 보인다. Dao 내의 메서드가 많을수록 서브클래스의 개수가 증가하기 때문이다.

##### 전략 패턴의 적용
개방 폐쇄 원칙을 잘 지키는 구조이면서도 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.
Service와 ServiceImple의 경우를 생각해볼 수 있다.

##### 테스트 클래스에서 배운점
테스트케이스는 추상클래스를 테스트할 때 extends 한 클래스로 오브젝트를 생성해서 테스트하여야 한다.

##### DI
앞에서 사용한 예로 컨텍스트(UserDao) 가 필요로 하는 전략 (ConnectionMaker.interface) 의 특정 구현 클래스 (DSimpleConnectionMaker) 오브젝트를 클라이언트 (UserDaoTest)에서 생성하여 제공해주는 방법. (DI) 위의 설명이 DI의 흐름이다. DI는 다양한 형태로 적용 할 수 있다. DI의 가정 중요한 개념은 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것이다. 이 개념만 따른다면 DI를 이루는 오브젝트와 구성요소 구조나 관계는 다양하게 만들 수 있다. 일반적으로 DI는 두 개의 오브젝트와 두 오브젝트를 연결해주는 오브젝트 팩토리(DI 컨테이너), 그리고 이를 사용하는 클라이언트라는 4개의 오브젝트 사이에서 일어난다.

##### 전략과 클라이언트의 동거
지금까지 예제를 하면서 많은 중복코드가 해결되고 깔끔해졌지만 그에 따른 문제점도 발생했다. 전략패턴을 사용하게되면 상속받을 서브클래스를 메서드 단위로 만들어야되기 때문에 전략패턴을 사용하지 않을 때보다 훨씬 많은 클래스를 만든다.
첫번째 해결방법은 클래스파일을 각 메서드안에 내부 클래스 파일로 만드는 것이다. 마치 로컬 변수를 선언하듯이 선언하면 된다. 로컬클래스는 선언된 메서드 내에서만 사용할 수 있다. 또한 메서드 내부에 로컬클래스가 존재하기 때문에 가독성도 나쁘지 않다.

##### 중첩클래스의 종류
다른 클래스 내부에 정의되는 클래스를 중첩클래스(nested class) 라고 한다. 중첩 클래스는 독립적으로 오브젝트로 만들어질 수 있는 스태틱 클래스와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스(inner class)로 구분된다. 내부 클래스는 다시 범위 (scope)에 따라 세 가지로 구분된다. 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스와 메서드 레벨에 정의되는 로컬클래스, 그리고 이름을 갖지 않는 익명 내부 클래스다. 익명 내부 클래스의 범위는 선언된 위치에 따라서 다르다.

##### 익명내부클래스 (nonymous inner class)
익명 내부 클래스는 이름을 갖지 않는 클래스이다. 오브젝트 생성이 결합된 형태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용한다. 클래스를 재사용할 필요도 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.
ex) new 인터페이스명() { 클래스 본문 };

##### JdbcContext의 특별한 DI
의존관계 주입이라는 개념을 충실히 따르자면 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않게하고, 런타임 시에 의존할 오브젝트와의 관계를 다이나믹하게 주입해주는 것이 맞다. 따라서 인터페이스를 사용하지 않았다면 엄밀히 말해서 온전한 DI라고 볼 수는 없다. 그러나 스프링의 DI는 넓게 보자면 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC라는 개념을 포괄한다. 그런 의미에서 JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입했다는 건 DI의 기본을 따르고 있다고 볼 수 있다. 인터페이스를 사용하지 않는 구조로 작성한 이유로 첫번째는 JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문이다. JdbcContext는 그 자체로 변경되는 상태정보를 갖고 있지 않다. dataSource라는 인스턴스 변수가 존재하긴 하지만 DataSource 오브젝트는 읽기전용이기 때문에 아무런 문제가 없다. 두번째는 JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문이다. 이 두번째 이유가 중요하다. JdbcContext는 DataSource 오브젝트를 주입받도록 되어있다. DI를 위해서는 주입되는쪽과 주입받는 쪽 모두가 스프링 빈으로 등록되어야 한다.

##### 코드를 이용한 수동 DI
기존의 DI는 빈을 생성하여 스프링의 컨테이너가 의존성을 주입하였지만, JdbcContext같은 XXXDao와 응집도가 높은 오브젝트의 경우 따로 빈으로 생성하지 않고 UserDao와 DataSource의 빈만으로 JdbcContext 오브젝트를 생성할 수 있다. 방법은 UserDao의 수정자 메서드 (setter)를 이용하는 것이다. UserDao에 DataSource를 주입 후 setDataSource의 메서드 안에서 JdbcContext 타입의 객체 생성 후 주입받은 DataSource를 사용하는 것이다. 이렇게 되면 UserDao가 임시로 DI 컨테이너처럼 동작하게 되는 것이다.

##### 템플릿과 콜백
템플릿과 콜백 패턴은 전략패턴의 익명 내부 클래스를 활용하는 방식을 말한다. 전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다.
템플릿 : 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다. jsp는 html이라는 고정된 부분에 el과 스크립트릿이라는 변하는 부분을 넣은 일종의 템플릿 파일이다.
콜백 : 실행되는 것을 목적으로 다른 오브젝트의 메서드에 전달되는 오브젝트를 말한다. 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메서드를 실행시키기 위해 사용한다. 자바에선 메서드 자체를 파라미터로 전달할 방법이 없기 때문에 메서드가 담긴 오브젝트를 전달해야 한다. 그래서 펑셔널 오브젝트(functional object) 라고도 한다.

특징 : 여러 개의 메서드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메서드 인터페이스를 사용한다. (functional Interface ?) 콜백 인터페이스에는 보통 파라미터가 있다. 이 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용된다. 매번 메서드 단위로 사용할 오브젝트를 새롭게 전달받는다는 것이 특징이다. 
템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 방식이다. 이 패턴은 전략패턴과 수동 DI(생성자 메서드를 통한 인터페이스를 생성하지않는 의존성주입)를 이해할 수 있어야 한다.
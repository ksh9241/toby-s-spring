# 스프링이란 무엇인가?
스프링은 기본적으로 IoC와 DI를 위한 컨테이너로서 동작하지만 그렇다고 "스프링은 단지 IoC/DI 프레임워크다" 라고 말할 수 없다. 그 단계를 넘어서 엔터프라이즈 애플리케이션 개발의 전 영역에 걸쳐 다양한 종류의 기술에 관여한다. 8장에서는 스프링의 사상과 가치, 그리고 적용된 원칙을 좀 더 깊이 있게 볼 것이다. 그 과정을 통해 스프링이란 도대체 무엇이고 왜 존재하는지를 좀 더 체계적으로 이해할 수 있다면 앞으로 스프링을 더 쉽게 이해하는 데 도움이 될 것이다.

### 스프링의 정의

자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

- 애플리케이션 프레임워크

프레임워크는 애플리케이션의 특정 계층에서 주로 동작하는 한 가지 기술 분야에 집중된다. 하지만 스프링은 이와 다르게 '애플리케이션 프레임워크' 라는 특징을 갖고 있다.
애플리케이션 프레임워크는 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다.

단지 여러 계층의 다양한 기술을 그저 한데 모아뒀기 때문에 애플리케이션 프레임워크라고 불리는 건 아니다. 애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기 때문에, 애플리케이션을 빠르고 효과적으로 개발할 수가 있다.

스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌으로써 애플리케이션을 편리하게 개발하게 해주는 애플리케이션 프레임워크로 사용되는 것임을 기억하자.

- 경량급

스프링 정의의 다음 항목은 경량급(lightweight') 이다. 스프링이 경량급이라고 해서 가볍다거나 작은 규모의 코드로 이루어졌다는 뜻은 아니다. 그럼에도 스프링이 가볍다고 하는 이유는 무엇일까? 그것은 불필요하게 무겁지 않다는 뜻이다. 스프링이 경량급이라는 표현이 사용된 것은 비교대상인 EJB와 대비하여 그러한 표현이 나온 것이다. 당시 EJB는 개발환경과 운용서버, 개발과 빌드, 테스트 과정, 작성돈 코드 모두를 매우 무겁고 복잡하게 만들었다. EJB가 동작하려면 고가의 자바 서버 was가 필요했다. 그렇기 때문에 고가의 제품으로 구성된 제대로 된 환경을 갖추지 못한다면 개발하기 힘들었다. 

반면 스프링은 단순한 서버환경인 톰캣이나 제티에서도 완벽하게 동작한다. 서블릿 컨테이너만으로 충분하니 EJB 컨테이너를 비롯해 고급 WAS를 굳이 사용하지 않아도 된다. 또한 EJB에서 사용하는 엔터프라이즈 개발의 고급 기술들 역시 사용할 수 있다. 결과적으로 스프링은 EJB를 대표하는 기술들이 불필요하게 무겁고 복잡했음을 증명한 셈이고 스프링은 군더더기 없는 깔끔한 기술을 가진 '경량급' 프레임워크라 불린 것이다.

같은 기능을 수행하는 코드인데도 스프링 기반의 코드가 가벼운 이유는 코드에 불필요하게 등장하던, 프레임워크와 서버환경에 의존적인 부분을 제거해주기 때문이다. 만들어진 코드가 지원하는 기술수준은 비슷하더라도 훨씬 빠르고 간편하게 작성하게 해줌으로써 생산성과 품질 면에서 유리하다는 것이 바로 경량급이라는 말로 표현되는 스프링의 특징이다.

- 자바 엔터프라이즈 개발을 편하게

스프링은 근본적인 부분에서 엔터프라이즈 개발의 근본적인 문제점에 도전해서 해결책을 제시한다는 것이 기존 기술의 접근방법과 스프링의 접근 방법의 차이점이다.
편리한 애플리케이션 개발이란 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말한다.
스프링은 애플리케이션 개발자들이 스프링이라는 프레임워크가 제공하는 기술이 아니라 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다.
또한 스프링은 엔터프라이즈 개발의 기술적인 복잡함과 그에 따른 수고를 제거해준다. 여기서 제거한다는 건 그런 기술적인 필요를 무시한다는 의미는 아니다. 엔터프라이즈 개발에서 필연적으로 요구되는 기술적인 요구를 충족하면서도 개발을 복잡하게 만들지 않는다는 점이 스프링의 뛰어난 면이다.

- 오픈소스

오픈소스란 말 그대로 소스가 모두에게 공개되고, 특별한 라이선스를 취득할 필요없이 얼마든지 가져다 자유롭게 이용해도 된다는 뜻이다. 스프링에 적용된 오픈소스 라이선스는 오픈소스 라이선스 중에서도 비교적 제약이 적고 사용이 매우 자유로운 편인 아파치 라이선스 버전 2.0이다.
오픈소스의 장점은 공개된 커뮤니티의 공간 안에서 투명한 방식으로 다양한 참여를 통해 개발되기 때문에 매우 빠르고 유연한 개발이 가능하다는 것이다.
단점으로는 지속적이고 안정적인 개발이 계속될지가 불확실하다는 것이다. 상당수의 오픈소스 제품은 핵심 개발자의 여가시간을 이용해 일종의 취미활동으로 만들어진다. 즉 개발자에게 극히 의존적이다. 이 문제는 오픈소스를 업무시간에 개발에 전념할 수 있는 전문 기업을 만들었다. 이를 통해 스프링의 핵심 개발자가 파트타임이나 여가시간 대신 정규 업무시간에 풀타임으로 오픈소스 개발에 전념할 수 있었고, 덕분에 안정적이고 전문화된 개발과 품질관리가 가능해졌다.

### 스프링의 목적

#### 엔터프라이즈 개발의 복잡함

##### 복잡함의 근본적인 이유 

- 첫 번째는 기술적인 제약조건과 요구사항이 늘어가기 때문이다.

엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말한다. 엔터프라이즈 시스템은 많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다. 또한 중요한 기업의 핵심 정보를 처리하거나 미션 크리티컬한 금융, 원자력, 항공, 국방 등의 시스템을 다루기도 하기 때문에 보안과 안정성, 확장성 면에서도 뛰어나야 한다. 즉 엔터프라이즈 시스템을 개발하는 데는 순수한 비즈니스 로직 외에도 기술적으로 고려해야 할 사항이 많다는 뜻이다.
엔터프라이즈 시스템이 기업 업무를 처리하는 데 핵심적인 역할로 등장하고 중요해지면서 점점 더 기술적인 요구는 심화되고 그에 따른 복잡도는 증가한다.

- 두 번째는 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가하기 때문이다.

점차 대부분의 업무 처리는 컴퓨터를 이용하지 않고는 아예 진행하기 힘들 만큼 엔터프라이즈 시스템에 대한 업무 의존도가 높아졌다. 그만큼 다양하고 복잡한 업무 처리 기능을 엔터프라이즈 시스템이 구현해야 했다는 뜻이다.

##### 복잡함을 증가시키는 원인
엔터프라이즈 애플리케이션 개발이 실패하는 주요 원인은 비즈니스 로직의 복잡함과 기술적인 복잡함이다. 세부요소가 이해하기 힘든 방식으로 얽혀 있고, 그 때문에 쉽게 다루기 어렵다는 의미다. 자칫 잘못 건드렸다가는 더 엉망이 되기 쉬우며, 들인 노력과 시간이 허사가 될 수도 있다.

각종 기술적인 API의 호출코드를 비즈니스 로직에 대한 구현 코드와 함께 덕지덕지 붙여서 만드는 것은 매우 어렵다. 더 큰 문제는 그렇게 기술과 비즈니스 로직의 복잡함에 엉켜 있는 코드를 유지보수하는 일이다.

#### 복잡함을 해결하려는 도전

##### 제거될 수 없는 근본적인 복잡함
근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아니다. 대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요하다. 문제는 비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 처리하는 데 적용되는 방법이 다르다는 점이다. 따라서 두 가지 복잡함이 코드에 한데 어우러져 나타나는 전통적인 개발 방식에서는 효과적으로 복잡함을 다루기가 힘들다. 따라서 가장 먼저 할 일은 성격이 다른 두 가지 복잡함을 분리해내는 것이다.

##### 비침투적인 방식을 통한 효과적인 해결책 : 스프링
EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우를 침투적인(invasive) 기술이라고 한다. 물론 꼭 필요한 기능을 사용해야 하기 때문에 특정 기술의 API를 이용하게 되는 건 어쩔 수 없다. 그런데 꼭 필요한 기능을 사용하는 것도 아니면서 단지 어떤 기술을 바탕으로 만들어진다고 해서 특정 클래스나 인터페이스, API 등의 코드에 마구 등장한다면 그것은 침투적인 기술이 되며 복잡함을 가중시키는 원인이 된다.

반면 비침투적인(non-invasive) 기술은 기술의 적용 사실이 코드에 직접 반영되지 않는다는 특징이 있다. 어딘가에서는 기술의 적용에 따라 필요한 작업을 해줘야 하겠지만, 애플리케이션 코드 여기저기에 불쑥 등장하거나, 코드의 설계와 구현 방식을 제한하지는 않는다는 게 비침투적인 기술의 특징이다.

스프링을 이용하면 기술적인 복잡함과 비즈니스 로직을 다루는 코드를 깔끔하게 분리할 수 있다. 중요한 점은 그 과정에서 스프링 스스로가 애플리케이션 코드에 불필요하게 나타나지 않도록 하는 것이다. 꼭 필요할 것 같은 경우조차도 기술 코드가 직접 노출되지 않도록 만들어줬다. 물론 스프링을 적용한다고 해서 근본적인 복잡함의 원인이 사라진 건 아니다. 하지만 스프링을 통해 성격이 다른 복잡함들을 깔끔하게 분리해줬기 때문에 각각을 효과적으로 상대할 수 있는 기반이 마련됐다.

### 복잡함을 상대하는 스프링의 전략

#### 기술적 복잡함을 상대하는 전략
스프링은 엔터프라이즈 기술을 적용했을 때 발생하는 복잡함의 문제를 두 가지로 분류하고 각각에 대한 적절한 대응 방법을 제공한다.

- 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.

환경이 바뀌고, 서버가 바뀌고, 적용되는 조건이 바뀌면 적용하는 기술이 달라지고 그에 따라 코드가 바뀐다는 건 심각한 문제다. 이렇게 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로 서비스 추상화다. 앞서 살펴봤던 트랜잭션 추상화나 OXM 추상화, 데이터 액세스에 관한 일관된 예외변환 기능, 트랜잭션 동기화 기법 등이 그런 대표적인 예이다. 

기술적인 복잡함은 일단 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부 기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책이다.
데이터 액세스 예외에 대한 추상화는 비즈니스 로직을 담은 서비스 레이어의 코드가 특정 기술이 발생시키는 예외에 종속되지 않고, 불필요하게 예외를 잡아야 하거나 throws를 선언해야 하는 것을 방지해준다.
스프링이 제공하는 템플릿/콜백 패턴은 판에 박힌 반복적인 작업 흐름과 API 사용코드를 제거해준다. 이를 통해 기술을 사용하는 코드도 최적화된 핵심 로직에만 집중하도록 도와준다.

- 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.

비즈니스 로직 전후로 경계가 설정돼야 하는 트랜잭션, 비즈니스 로직에 대한 보안 적용, 계층 사이에 주고받는 데이터와 예외의 일괄 변환이나 로깅이나 감사(audit) 기능 등이 대표적인 예다.
책임에 따라 계층을 구분하고 그 사이에 서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다고 할지라도 근본적으로 엔터프라이즈 서비스를 적용하는 한 이런 문제는 쉽게 해결할 수 없다. 이런 문제를 해결하기 위한 스프링의 접근 방법은 바로 AOP다. AOP를 적용하지 않았을 떄는 기술과 비즈니스 로직이 지저분하게 얽혀서 다루기 힘들다는 문제도 있지만, 기술적인 코드가 여기저기 중복돼서 나타난다는 것도 심각한 문제점이다. AOP는 기술을 다루는 코드로 인한 복잡함이 기술 그 자체 이상으로 불필요하게 증대되지 않도록 도와주는 가장 강력한 수단이다.

##### 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
비즈니스 로직을 담은 코드는 애플리케이션에서 가장 중요한 핵심이 되는 부분이다. 또한 업무의 변화에 따라 자주 변경되거나 수정되는 부분이기도 하다. 따라서 대체로 복잡하다. 과거에는 비즈니스 로직의 상당 부분을 DB에 두는 것이 유행이었다. SQL을 통해 비즈니스 로직을 표현하고, DB에서 동작하는 저장 프로시저를 통해 핵심 로직을 처리하는 경우도 많았다. 하지만 엔터프라이즈 시스템의 규모가 커지고, 복잡함이 증가하면서 DB에 비즈니스 로직을 두는 건 불편할뿐더러 위험한 일이라고 여겨지기 시작했다. 따라서 엔터프라이즈 시스템 개발의 흐름은 점차로 비즈니스 로직은 애플리케이션 안에서 처리하도록 만드는 추세다.

비 침투적인 기술인 스프링은 핵심 로직을 다루는 코드에는 (특별한 이유가 없다면) 스프링의 흔적조차 찾을 수 없을 만큼 자신을 드러내지 않는다. 다만 비즈니스 로직을 담당하는 오브젝트들에게 적절한 엔터프라이즈 기술 서비스가 제공되도록 은밀히 도와줄 뿐이다. 결국 비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체다.

##### 핵심도구 :객체지향과 DI
자바의 기본인 객체지향에 충실한 설계가 가능하도록 단순한 오브젝트로 개발할 수 있고, 객체지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록 도와주는 것이 스프링의 기본 전략이다. DI란 특별한 기술이라기보다는 유연하게 확장할 수 있는 오브젝트 설계를 하다 보면 자연스럽게 적용하게 되는 객체지향 프로그래밍 기법일 뿐이다.
DI를 의식하다 보면 오브젝트를 설계할 때 자주 DI를 적용할 후보가 더 이상 없을까를 생각해보게 된다. 그리고 그런 후보를 찾을 수 있다면 DI를 적용해서 오브젝트를 분리하고, 인터페이스를 도입하고, DI로 관계를 연결해줄 것이다.

### POJO 프로그래밍
스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것 이라고 했다. 엔터프라이즈 서비스라고 하는 것은 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술을 말한다. 이런 기술을 POJO에 제공한다는 말은 엔터프라이즈 서비스 기술과 POJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻이기도 하다. 분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공한다는 것이 스프링의 가장 강력한 특징과 목표다.

##### 스프링의 핵심 :POJO
스프링의 주요 기술인 IoC/DI, AOP와 PSA(Portable Service Abstraction)는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능기술(enabling technology)이라고 불린다.

##### POJO란 무엇인가?
POJO란 Plain Old Java Object 의 첫 글자를 따서 만든 약자다. 이 단어가 생겼을 시기는 2000년 대 인데 당시 인기가 있던 EJB처럼 복잡하고 제한이 많은 기술을 사용하는 것보다는 자바의 단순한 오브젝트를 이용해 애플리케이션의 비즈니스 로직을 구현하는 편이 낫다고 생각해서 나온 단어이다. 쉽게 말하면 "간단한 자바오브젝트를 사용한다." 로 이해하면 된다.

##### POJO의 조건
- 특정규약(contract) 에 종속되지 않는다.

POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다. 따라서 EJB2와 같이 특정 규약에 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다. 특정 규약을 따라 만들게 하는 경우는 대부분 규약에서 제시하는 특정 클래스를 상속하도록 요구한다. 그럴경우 자바의 단일 상속 제한 때문에 더 이상 클래스에 객체지향적인 설계 기법을 적용하기가 어려워지는 문제가 생긴다. 또한 규약이 적용된 환경에 종속적이기 때문에 다른 환경으로 이전이 힘들다는 문제점이 있다.
별다른 가치를 주지도 못하는 규약 따위에 종속되지 않아야 하고, 객체지향 설계의 자유로운 적용이 가능한 오브젝트여야만 POJO라고 불릴 수 있다.

- 특정 환경에 종속되지 않는다.

특정환경에 종속적이어야만 동작하는 오브젝트도 POJO라고 할 수 없다. 예시로 EJB3 은 어떤면에서 POJO에 가까운 설계와 구현이 가능해졌다. 하지만 여전히 JNDI라는 서버 서비스를 필요로 하기 때문에 JNDI와 같은 특정 환경이 의존 대상 검색 방식에 종속적이라면 POJO라 할 수 없다. 또 다른 예시로는 WebLogic 서버에서만 사용 가능한 API를 직접 쓴 코드를 갖고 있거나, 특정 OS에서 제공하는 기능을 직접 호출하도록 만들어진 오브젝트 등이다.

특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안 된다. 설령 나중에는 웹 컨트롤러와 연결돼서 사용될 것이 뻔하다고 할지라도 직접적으로 웹이라는 환경으로 제한해버리는 오브젝트나 API에 의존해선 안된다. 그렇게 하면 웹 외의 클라이언트가 사용하지 못하게 된다. 또 웹 서버에 올리지 않고 독립적으로 테스트하기도 힘들어진다.

비즈니스 로직을 담은 코드에 HttpServletRequest나 HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워크의 클래스를 직접 이용하는 부분이 있다면 그것은 진정한 POJO라고 볼 수 없다.

특정 기술규약과 환경에 종속되지 않으면 모두 POJO라고 말할 수 있을까?  많은 개발자가 크게 오해하고 있는 것 중 하나가 이것이다. 그저 평범한 자바 클래스를 써서 개발했다고 해서 POJO 방식으로 개발했다고 생각한다. 단지 자바 문법을 지키고 순수하게 javaSE API만 사용했다고 해서 그 코드를 POJO라고 할 수는 없다. POJO는 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 하기 때문이다.

진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.

##### POJO의 장점
특정한 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다. 또 POJO로 개발된 코드는 자동화된 테스트에 매우 유리하다. 그리고 객체지향적인 설계를 자유롭게 적용할 수 있다는 것도 큰 장점이다. 개발자들이 자바와 객체지향 프로그래밍, 모델링과 설계에 대해 배울 때 그려봤던 도메인 모델과, 오랜 경험을 통해 쌓여온 재활용 가능한 설계 모델인 디자인 패턴 등은 POJO가 아니고는 적용하기 힘들다.

##### POJO 프레임워크
POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO 프레임워크라고 한다. 스프링 프레임워크와 하이버네이트를 대표적인 POJO 프레임워크로 꼽을 수 있다.
스프링을 이용하면 POJO 프로그래밍의 장점을 그대로 살려서 엔터프라이즈 애플리케이션의 핵심 로직을 객체지향적인 POJO를 기반으로 깔끔하게 구현하고, 동시에 엔터프라이즈 환경의 각종 서비스와 기술적인 필요를 POJO 방식으로 만들어진 코드에 적용할 수 있다.

### 스프링의 기술
스프링에서는 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술을 제공한다. 그 세가지 기술은 바로 IoC/DI, AOP, Portable Service Abstraction(엔터프라이즈 서비스 추상화) 이다. 객체지향 설계와 개발원리를 잘 적용하다보면 자연스럽게 만들어지는 것이다. 다만 스프링은 그것을 통일성 있게, 더 세련된 방법으로, 자바 엔터프라이즈 개발의 전 영역에 걸쳐 효과적으로 적용될 수 있도록 프레임워크 형태로 제공하고 있다.

##### 제어의 역전 / 의존관계 주입
IoC/DI는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 하다. 나머지 두 가지 기술인 AOP와 PSA도 IoC/DI에 바탕을 두고 있다. 3대기술은 아니지만 자주 등장하는 템플릿/콜백 패턴이 적용된 부분도 IoC/DI가 그 핵심 원리다.
왜 두개의 오브젝트를 분리해서 만들고, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 것일까? 오브젝트를 지정 후 new키워드로 생성하여 사용하는 강한 결합을 쓰는 방법보다 나은 점은 무엇일까 에 대한 답은 '유연한 확장이 가능하게 하기 위해서'라고 할 수 있다. 
DI는 개방 폐쇄 원칙이라는 객체지향 설계 원칙으로 잘 설명될 수 있다. 유연한 확장이라는 장점은 'OCP의 확장에는 열려있고 변경에는 닫혀있다.' 라는 말로도 설명이 가능하다. 폐쇄 관점에서 볼 때 장점은 재사용이 가능하다라고 볼 수 있다.

##### DI의 활용 방법
- 핵심기능의 변경

DI의 가장 대표적인 적용 방법은 바로 의존대상의 구현을 바꾸는 것이다. 디자인 패턴의 전략 패턴이 대표적인 예다. A->B구조에서 A의 기능 일부를 B에게 위임한다고 했을 때 B의 구현 방식을 필요에 따라 통째로 B1, B2, B3로 바꾸는 것이다. 쉽게말해 DAO가 있다고 했을 때 구현을 JDBC에서 JPA, mybatis 등으로 변경하는 것을 생각할 수 있다.

- 핵심기능의 동적인 변경
첫 번째랑 비슷하게 의존 오브젝트의 핵심기능 자체를 바꾸는 것이다. 동적으로 매번 다르게 변경할 수 있다. DI도 기본적으로 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것이긴 하지만, 일단 DI 되고 나면 그 후로는 바뀌지 않는다. 즉 동적인 방식으로 연결되지만 한번 DI되면 바뀌지 않는 정적인 관계를 맺어준다. 하지만 DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존대상을 다이나믹하게 변경할 수 있다. 예를들자면 등급에 따라 다른 DataSource를 사용하게 만들 수도 있다. DAO는 DataSource에 의존한다. DAO -> DataSource 관계가 만들어지지만 하나의 DAO는 여러개의 DataSource를 의존하게 만들 수도 있다. VIP 사용자는 좀 더 속도가 빠른 DB를 이용하게 해서 빠른 처리 속도를 보장해주려고 할 때 적용할 수 있는 기법이다.

또 다른 예로는 사용자별로 모두 독립적인 의존 오브젝트를 두게 만들 수도 있다. 한번 로그인한 사용자는 로그아웃하거나 다른 브라우저로 다시 들어오기 전에는 계속 자신만의 오브젝트를 유지하게 하고 서비스 오브젝트가 이를 DI 받아서 사용하게 할 수 있다.
동적인 방식으로 핵심 기능을 변경하는 건, 기술적으로 보자면 다이나믹 라우팅 프록시나 프록시 오브젝트 기법을 활용한 것이다.

- 부가기능의 추가

핵심기능은 그대로 둔 채로 부가기능을 추가하는 것이다. 데코레이터 패턴을 생각해보면 된다. 인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있다. 그래서 핵심기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있다.

- 인터페이스의 변경

때로는 사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우가 있다. 또는 여러 종류의 인터페이스를 가졌지만 사실은 비슷한 기능을 담당하는  오브젝트를 바꿔가면서 사용하고 싶을 때도 있다. A가 C 오브젝트를 사용하려 한다고 해보자. 하지만 A는 원래 B 인터페이스를 사용하도록 만들어져 있고 C는 B 인터페이스를 구현하지 않았다. 이 때 A가 DI를 통해 B의 구현 오브젝트를 받도록 만들어져 있다면 B 인터페이스를 구현했으면서 내부에서 C를 호출해주는 기능을 가진 어댑터 오브젝트를 만들어 A에 DI 해주면 된다. 디자인 패턴에서 말하는 오브젝트 방식의 어댑터 패턴의 응용이라고 볼 수 있다.

- 프록시

필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연로딩을 적용하려면 프록시가 필요하다. 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 필요하다. 스프링은 EJB 원격 호출을 포함해서 웹 서비스, REST호출, HTTP 방식의 호출 등 다양한 리모팅 기술을 지원한다.

- 템플릿과 콜백

템플릿/콜백 패턴은 DI의 특별한 적용 방법이다. 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 이를 DI 원리를 응용해 적용하면 지저분하게 매번 만들어야 하는 코드를 간결하게 만들 수 있다. 콜백을 템플릿에 주입하는 방식으로 동작하게 하는 것은 DI의 원리에 가장 충실한 응용 방법이다.
콜백을 얼마든지 만들어서 사용할 수 있다는 건 개방을 통한 유연한 확장성을 보여주는 것이며, 템플릿은 한 번 만들어두면 계속 재사용할 수 있다는 건 기능의 확장에도 변하지 않는다는 OCP의 폐쇄 원칙에 가장 잘 들어맞는 것이다.

- 싱글톤과 오브젝트 스코프

DI가 필요한 중요한 이유 중 한가지는 DI 할 오브젝트의 생명주기를 제어할 수 있다는 것이다. 오브젝트를 컨테이너가 관리한다는 의미다. 오브젝트의 생성부터 관계설정, 이용, 소멸에 이르기까지의 모든 과정을 DI컨테이너가 주관하기 떄문에 그 오브젝트의 스코프를 자유롭게 제어할 수 있다. 가장 기본이 되는 스코프는 싱글톤이다. 하나 또는 소수의 오브젝트가 수많은 클라이언트를 상대로 고성능 서비스를 제공하는 방식은 엔터프라이즈 개발에서 매우 중요하다. 전통적인 싱글톤 패턴은 오브젝트에 많은 제약을 가해서 만들어지기 때문에 그다지 권장되지 않는다. 그보다는 컨테이너가 오브젝트를 관리하는 IoC 방식이 유용하다. 컨테이너가 알아서 싱글톤을 만들고 관리하기 때문에 클래스 자체는 싱글톤을 고려하지 않고 자유롭게 설계해도 된다는 장점이 있다.

- 테스트

여타 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것이다. 즉 다른 오브젝트와 사이에서 일어나는 일은 테스트를 위해 조작할 수 있도록 만든다.
의존 오브젝트를 대신해서 스텁 또는 목 오브젝트 같은 테스트 대역을 활용해야 한다. 이때도 DI는 중요한 역할을 한다. 수정자 메서드를 통한 DI를 하면 수동으로 목 오브젝트를 주입할 수 있다.

##### 애스펙트 지향 프로그래밍 (AOP)
사실 애스펙트 지향 프로그래밍은 객체지향 프로그래밍(OOP) 처럼 독립적인 프로그래밍 패러다임이 아니다. AOP와 OOP는 서로 배타적이 아니라는 말이다. 객체지향 기술은 성공적인 프로그래밍 방식이지만 한편으로는 점점 복잡해져 가는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는데 한계가 있기도 하다. AOP는 바로 이러한 객체지향 기술의 한계와 단점을 극복하도록 도와주는 보조적인 프로그래밍 기술이다.

스프링의 목적인 POJO만으로 엔터프라이즈 애플리케이션을 개발하면서도 엔터프라이즈 서비스를 선언적으로 제공하는 데 반드시 필요한 것이 바로 이 AOP기술이다. 일부 서비스는 순수한 객체지향 기법만으로는 POJO의 조건을 유지한 채로 적용하기 힘들다. 바로 이런 문제를 해결하기 위해 AOP가 필요하다.

##### AOP의 적용 기법
- 스프링과 같이 다이나믹 프록시를 사용하는 방법

이 방법은 기존 코드에 영향을 주지 않고 부가기능을 적용하게 해주는 데코레이터 패턴을 응용한 것이다. 자바의 객체지향 패턴을 활용한 방법이기 때문에 만들기 쉽고 적용하기 간편하지만 부가기능을 부여할 수 있는 곳은 메서드의 호출이 일어나는 지점뿐이라는 제약이 있다. (재사용이 불가능하다는 의미인듯하다.)
부가기능을 구현한 코드나 기능을 적용할 대상을 찾는 방법 모두 평범한 자바 클래스로 만들면 된다. 엔터프라이즈 개발에서 필요로 하는 AOP는 대부분 이 프록시 방식의 AOP면 된다.

- 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법

AspectJ는 강력한 고급 기능을 가진 AOP를 제공한다. AspectJ는 프록시 방식의 AOP에서는 불가능한 다양한 조인 포인트를 제공한다. 메서드 호출뿐 아니라 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메서드 호출 등에도 부가기능을 제공할 수 있다. 이런 고급 AOP를 적용하려면 자바 언어와 JDK의 지원만으로는 불가능하다. 사용하기 까다롭고 번잡하지만 경우에 따라서는 프록시 방식의 AOP로는 할 수 없는 작업을 위해 AspectJ를 사용해야 한다.

##### AOP의 적용 단계
- 1단계 : 미리 준비된 AOP 이용

일단 처음에는 스프링이 미리 만들어서 제공하는 AOP 기능을 그대로 가져다 적용하는 것으로 시작한다. 스프링이 제공하는 대표적인 AOP는 트랜잭션이다. 스프링에는 트랜잭션만큼 자주 사용되진 않지만 특정 아키텍처를 선택했을 때 사용할 수 있도록 준비된 AOP 기능이 하나 더 있다. @Configurable 어노테이션을 이용해서 도메인 오브젝트에 DI를 자동적용해주는 AOP 기능이다. 이 두 가지가 스프링이 미리 준비해서 제공하는 대표적인 AOP 기능이다. 두 가지 모두 간단한 설정을 추가하는 것만으로도 적용되기 때문에 AOP에 대한 지식이나 경험이 많지 않더라도 간단히 이용 가능하다는 장점이 있다.

- 2단계 : 전담팀을 통한 정책 AOP 적용
비즈니스 로직을 가진 오브젝트에 대한 보안, 특정 계층의 오브젝트 이용 전후의 작업 기록을 남기는 로깅, 데이터 추적을 위한 트레이싱, 특정 구간의 실시간 성능 모니터링과 같은 정책적으로 적용할 만한 기능에 AOP를 이용하는 것이다. 예를 들면 레이어 간의 호출에 대한 제한이 있다고 생각해보자. JSP 뷰에서는 DAO나 서비스 계층의 오브젝트를 직접 호출하면 안된다는 정책이 있다. 이런 것을 코드 리뷰를 통해 일일이 검증하기는 쉽지 않다. 이럴 때 AOP가 유용하게 쓰일 수 있다. 모든 DAO의 메서드 호출에 적용되는 AOP 모듈을 하나 만든다. 그리고 메서드 호출이 일어났을 때 어드바이스를 통해 호출 경로를 조사할 수 있다. 이렇게 AOP는 동적으로 동작하면서 개발 정책을 위반한 코드를 잡아내는 데도 유용하다.

- 3단계 : AOP의 자유로운 이동
첫 번째와 두 번째 단계를 거쳐서 AOP에 어느정도 친숙해지고, 그 장단점과 응용 전략, 위험성 등을 어느정도 이해했다면 이제는 개발자 스스로가 AOP를 활용할 수 있는 단계로 넘어갈 수 있다.

##### 포터블 서비스 추상화 (PSA)
스프링은 엔터프라이즈 개발에 사용되는 다양한 기술에 대한 서비스 추상화 기능을 제공한다. 트랜잭션 서비스 추상화는 코드를 이용해 트랜잭션을 제어하지 않는다면 직접 이용할 이유가 없다. 대신 설정에서는 스프링의 트랜잭션 추상화 인터페이스인 PlatformTransactionManager를 구현한 구체적인 서비스 클래스를 빈으로 등록해줘야 한다.
직접 스프링이 제공하는 API를 사용해서 만드는 경우도 있다. OXM이나 JavaMail을 이용한다면 스프링이 정의한 추상 API를 이용해 코드를 작성한다. 그리고 구체적인 기술과 설정은 XML 파일 안에서 지정한다.
서비스 추상화를 위해 필요한 기술은 DI뿐이다. 결국 DI 응용 방법의 한 가지이므로 DI를 적극 활용해서 개발한다면 서비스 추상화는 자연스럽게 만들어 쓸 수 있다.

# 정리
8장에서는 스프링의 기본적인 정의와 그 목적 그리고 그것을 이루기 위해 제공하는 기술을 간략히 살펴봤다.
- 스프링은 그 개발철학과 목표를 분명히 이해하고 사용해야 한다.
- 스프링은 오픈소스 소프트웨어이며, 애플리케이션 개발의 모든 기술과 영역을 종합적으로 다루는 애플리케이션 프레임워크다.
- 엔터프라이즈 애플리케이션 개발의 복잡함은 비즈니스 로직과 엔터프라이즈 시스템의 기술적인 요구에 의해 발생한다.
- 자바의 근본인 객체지향적인 원리에 충실하게 개발할 수 있으며, 환경과 규약에 의존적이지 않는 POJO를 이용한 애플리케이션 개발은 엔터프라이즈 시스템 개발의 복잡함을 주는 많은 문제를 해결할 수 있다.
- 스프링의 목적은 이런 POJO를 이용해 엔터프라이즈 애플리케이션을 쉽고 효과적으로 개발할 수 있도록 지원해주는 데 있다.
- POJO 방식의 개발을 돕기 위해 스프링은 IoC/DI, AOP, PSA와 같은 가능기술을 프레임워크와 컨테이너라는 방식을 통해 제공한다.
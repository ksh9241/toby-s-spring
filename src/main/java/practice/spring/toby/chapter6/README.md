# AOP
AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다. AOP를 바르게 이용하려면 OOP를 대체하려고 하는 것처럼 보이는 AOP라는 이름 뒤에 감춰진, 그 필연적인 등장배경과 스프링이 그것을 도입한 이유, 그 적용을 통해 얻을 수 있는 장점이 무엇인지에 대한 충분한 이해가 필요하다. 스프링에 적용된 가장 인기 있는 AOP의 적용대상은 선언적 트랜잭션 기능이다.

### 트랜잭션 코드의 분리
스프링이 제공하는 깔끔한 트랜잭션 인터페이스를 사용하였음에도 불구하고 비즈니스 로직의 주인이어야할 메서드 안에 트랜잭션 코드가 더 많은 자리를 차지하고 있다. 그렇다고해서 논리적으로 트랜잭션 코드를 다른 로직에서 처리하는 것은 맞지않다.

##### 메서드 분리
```JAVA
public void upgradeLevels() {
		// 트랜잭션 추상화 API를 적용
		TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); 
		
		// 비즈니스 로직 시작.
		try {
			List<User> users = userDao.getAll();
			for (User user : users) {
				if (changeUpgradeLevel(user)) {
					upgradeLevel(user);
				}
			}
		// 비즈니스 로직 끝.
		
			transactionManager.commit(status);
		} catch (Exception e) {
			transactionManager.rollback(status);
			throw e;
		} 
	}
```

비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있다. 또 이 코드의 특징은 트랜잭션 경계설정의 코드와 비즈니스로직 코드 간에 서로에게 요청하는 정보가 없다는 것이다. 비즈니스 로직에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 필요가 없다. 따라서 이 두 가지 코드는 성격이 다를 뿐 아니라 서로 주고받는 것도 없는 완벽하게 독립적인 코드다.

##### DI 적용을 이용한 트랜잭션 분리
구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점이다. 직접 사용하는 것이 문제가 된다면 간접적으로 사용하면된다. DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접적으로 접근하는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변결할 수 있다. 바로 이런 개념을 가진 DI가 지금 필요하다. 
(예제 practice.spring.toby.chapter6 : UserServiceTx, UserServiceImple )

##### 트랜잭션 경계설정 코드 분리의 장점
1. 비즈니스 로직을 담당하고 있는 UserServiceImple의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다. 스프링의 JDBC나 JTA 같은 로우레벨의 트랜잭션 API는 물론이고 스프링의 트랜잭션 추상화 API조차 필요 없다. 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.

##### 복잡한 의존관계 속 테스트
복잡한 의존관계를 갖는 오브젝트들이 테스트를 진행되는 동안에 같이 실행된다. 더 큰 문제는 그 세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 것이 아니라는 점이다. 의존관계 오브젝트 역시 다른 오브젝트의 의존관계를 갖고 있다면 꼬리물기 식으로 계속 오브젝트가 실행된다. 그 어느 것이라도 바르게 셋업되어 있지 않거나, 코드에 문제가 있다면 그 때문에 우리가 테스트하려는 오브젝트에 대한 테스트가 실패해버린다. 이런 경우의 테스트는 준비하기 힘들고, 환경이 조금이라도 달라지면 동일한 테스트 결과를 내지 못할 수도 있으며, 수행 속도는 느리고 그에 따라 테스트를 작성하고 실행하는 빈도가 점차로 떨어질 것이 분명하다.

##### 테스트 대상 오브젝트 고립시키기
그래서 테스트 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. 예시로 MailSender인터페이스를 고립시키는 DummyMailSender 같은 클래스가 있다. 또는 MockMailSender라는 목 오브젝트도 사용했다.

##### 고립된 단위 테스트 활용
예제 Chapter6UserServiceTest

다섯 단계의 테스트
1. 테스트 실행에 필요한 유저 DB 데이터 주입.
2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트 DI
3. 실제 테스트 대상인 UserServiceImple 의 메서드 실행
4. 결과가 DB에 반영됐는지 확인하기 위해 UserDao를 통한 데이터 가져오기 (UserServiceImple의 upgradeLevels())
5. 목 오브젝트를 통한 UserServiceImple에 의한 메일 발송이 있었는지 확인.

##### 단위 테스트와 통합 테스트
단위테스트 : 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것
통합테스트 : 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
- DB와 연동하는 오브젝트의 경우 분리해서 단위테스트로 만들기 힘들기 때문에 DB까지 하나로 묶어서 단위테스트로 진행한다.
- 각각의 단위테스트에서 성공하였더라도 단위테스트를 연결하여 통합테스트를 진행했을 때 오류가 발생할 수도 있다. 하지만 단위테스트에서 오류가 없었기 때문에 오류를 발견하기가 훨씬 수월하다.
- 단위테스트를 만들기가 너무 복잡하다고 판단되면 통합테스트를 고려한다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트이다. (JUnit)

테스트 코드를 만들려는 노력을 게을리하면 테스트 작성이 불편해지고, 텟트ㅡ를 잘 만들지 않게 될 가능성이 높아진다. 테스트가 없으니 과감하게 리팩토링 할 엄두를 내지 못할 것이고 코드의 품질은 점점 떨어지고 유연성과 확장성을 잃어갈지 모른다.

##### 목 프레임워크
목 오브젝트를 만들 때 테스트에서는 사용하지 않는 인터페이스도 모두 일일이 구현해줘야한다. 검증 기능이 있는 목 오브젝트를 만들려면, 메서드의 호출 내용을 저장했다가 이를 다시 불러오는 것도 매번 귀찮은 일이 아닐 수 없다. (JavaMail, MockUserDao ... ) 다행이도 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.

##### Mockito 프레임워크
Mockito 프레임워크는 사용하기도 편리하고, 코드도 직관적이라 최근 많은 인기를 끌고 있다.
목 오브젝트 사용 네가지 단계 * 두 번째와 네 번째는 각각 필요할 경우에만 사용할 수 있다.
1. 인터페이스를 이용해 목 오브젝트를 만든다.
2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메서드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
4. 테스트 대상 오브젝틀ㄹ 사용한 후에 목 오브젝트의 특정 메서드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

- times() : 메서드의 호출 횟수를 검증해준다.
- any()    : 파라미터의 내용은 무시하고 호출 횟수만 확인할 수 있다.
- verify().update(users.get(1)) : users.get(1)을 파라미터로 update() 호출된 적 있는지 확인해준다. update()가 호출된적이 없거나 파라미터가 users(1) 이 아니라면 테스트는 실패한다.

MailSender의 경우 ArgumentCaptor을 사용하여 실제 MailSender 목 오브젝트에 전달된 파라미터를 가져와 내용을 검증하는 방법을 사용했다. 파라미터를 직접 비교하기보다 파라미터의 내부 정보를 확인해야 하는 경우에 유용하다.

### 다이나믹 프록시와 팩토리 빈
핵심 기능과 부가기능을 인터페이스를 통해서 구현한다. 부가기능을 담은 클래스는 중요한 특징이 있다. 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다. 핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다. 따라서 부가기능은 핵심기능을 사용하는 구조가 되는 것이다. 부가기능 코드에서 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다.비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바로 그런 대표적인 경우다. 이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다.
프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.

##### 프록시의 사용목적
1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다.
2. 타깃에 부가적인 기능을 부여해주기 위해서다.

두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만, 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분된다.

##### 데코레이터 패턴
데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다. 다이나믹하게 기능을 부가한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다. 이 패턴의 이름이 데코레이터라고 불리는 이유는 마치 제품이나 케익 등을 여러 겹으로 포장하고 그 위에 장식을 붙이는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있기 때문이다. 또한 프록시가 직접 타깃을 고정시킬 필요가 없기 때문에 같은 인터페이스를 구현한 타켓과 여러개의 프록시를 사용할 수 있다.

ex) 클라이언트 -> 라인넘버 데코레이터 -> 컬러 데코레이터 -> 페이징 데코레이터 -> 소스코드 출력 기능 (타깃)

##### 프록시 패턴
데코레이션 패턴은 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법이었다면 프록시패턴은 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다. 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다. 
프록시와 데코레이터는 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다. 물론 인터페이스를 통해 위임하도록 만들 수도 있다.

ex) 클라이언트 -> 접근제어 프록시 -> 컬러 데코레이터 -> 페이징 데코레이터 -> 소스코드 출력기능

##### 다이나믹 프록시
프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 오브젝트다. 다이나믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다. 클라이언트는 다이나믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다. 이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다. 하지만 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다. 부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.


프록시 기능
- 타깃과 같은 메서드를 구현하고 있다가 메서드가 호출되면 타깃 오브젝트로 위임한다.
- 지정된 요청에 대해서는 부가기능을 수행한다.

프록시 작성의 문제점
- 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다. 부가기능이 필요 없는 메서드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야한다. 복잡하진 않지만 인터페이스의 메서드가 많아지고 다양해지면 상당히 부담스러운 작업이 될 것이다. 또 타깃 인터페이스가 변경되면 함께 수정해줘야 한다는 부담도 있다.
- 부가기능 코드가 중복될 가능성이 많다는 점이다.

##### 리플렉션
리플렉션이란 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.  ( 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법 )
BeanFactory는 어플리케이션이 실행한 후 객체가 호출 될 당시 객체의 인스턴스를 생성하게 되는데 이 때 필요한 기술이 Reflection이다.
실행중인 자바프로그램 내부를 검사하고 내부의 속성을 수정할 수 있도록 한다.
```JAVA
@Test
	public void invokeMethod() throws Exception {
		String name = "String";
		
		// length()
		assertThat(name.length(), is(6));
		
		Method lengthMethod = String.class.getMethod("length");
		assertThat((Integer) lengthMethod.invoke(name), is(6));
		
		// charAt()
		assertThat(name.charAt(0), is('S'));
		
		Method charAtMethod = String.class.getMethod("charAt", int.class);
		assertThat((Character) charAtMethod.invoke(name, 0), is('S'));
```

##### 다이나믹 프록시
다이나믹 프록시는 팩토리에 의해 런타임 시 동적으로 만들어지는 오브젝트이다. 클라이언트는 다이나믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다. 이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다. 다이나믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다. 부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다. 다이나믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메서드로 넘긴다. 타깃 인터페이스의 모든 메서드의 요청이 하나의 메서드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.

```JAVA
public class UppercaseHandler implements InvocationHandler {

	Hello target;
	
	public UppercaseHandler (Hello target) {
		this.target = target;
	}
	
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		String ret = (String) method.invoke(target, args); // 타깃으로 위임. 인터페이스의 메서드 호출에 모두 적용된다.
		return ret.toUpperCase();
	}
}
```

##### 다이나믹 프록시를 위한 팩토리 빈
DI의 대상이 되는 다이나믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법이 없다는 점이다. 스프링의 빈은 기본적으로 클래스 이름과 프로퍼티로 정의된다. 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클래스의 오브젝트를 만든다. Class의 newInstance() 메서드는 해당 클래스의 파라미터가 없는 생성자를 호출하고, 그 결과 생성되는 오브젝트를 돌려주는 리플렉션  API다.
ex ) Date now = (Date) Class.forName("java.util.Date").newInstance();

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다. 문제는 다이나믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다는 점이다. 다이나믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메서드를 통해서만 만들 수 있다.

##### 팩토리 빈
스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다. 대표적으로 팩토리빈을 이용한 빈 생성 방법을 들 수 있다. 팩토리 빈을 만드는 방법은 여러가지가 있는데 가장 간단한 방법은 FactoryBean 이라는 인터페이스를 구현하는 것이다.

```JAVA

public interface FactoryBean<T> {
	T getObject() throws Exception;	// 빈 오브젝트를 생성해서 돌려준다.
	Class<?> getObjectType();		// 생성되는 오브젝트의 타입을 알려준다.
	boolean isSingleton();		// getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.
}

// 생성자를 제공하지 않는 클래스
public class Message {

	String text;
	
	// 생성자가 private으로 선언되어 있어서 외부에서 생성자를 통한 오브젝트를 만들 수 없다.
	private Message (String text) {
		this.text = text;
	}
	public String getMessage() {
		return this.text;
	}
	
	// 생성자 메서드 대신 사용할 수 있는 스태틱 팩토리 메서드를 제공한다.
	public static Message newMessage (String text) {
		return new Message(text);
	}
}
```

사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다. 리플렉션은 private으로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문이다. 하지만 생성자를 private으로 만들었다는 것은 스태틱 메서드를 통해 오브젝트를 만들어져야 하는 중요한 이유가 있기 때문이므로 이를 무시하고 오브젝트를 강제로 생성하면 위험하다.

##### 다이나믹 프록시를 만들어주는 팩토리 빈
Proxy의 newProxyInstance() 메서드를 통해서만 생성이 가능한 다이나믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다. 대신 팩토리 빈을 사용하면 다이나믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수가 있다. 스프링 빈 설정에는 팩토리 빈과 타깃 클래스만 빈으로 등록한다. 팩토리 빈은 다이나믹 프록시가 위임할 타깃 오브젝트에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다. 그 외에도 다이나믹 프록시나 TransactionHandler를 만들 때 필요한 정보는 팩토리 빈의 프로퍼티로 설정해뒀다가 다이나믹 프록시를 만들면서 전달해줘야 한다. (1권 454p 이미지 참조)

##### 트랜잭션 프록시 팩토리 빈 테스트
TransactionHandler와 다이나믹 프록시 오브젝트를 직접 만들어서 테스트했을 때는 타깃 오브젝트를 바꾸기가 쉬웠는데 이제는 스프링 빈에서 생성되는 프록시 오브젝트에 대해 테스트를 해야 하기 때문에 간단하지 않다. 가장 문제는 타깃 오브젝트에 대한 레퍼런스는 TransactionHandler 오브젝트가 갖고 있는데, TxProxyFactoryBean 내부에서 만들어져 다이나믹 프록시 생성에 사용될 뿐 별도로 참조할 방법이 없다는 점이다. 방법은 빈으로 등록된 TxProxyFactoryBean을 직접 가져와서 프록시를 만들어 보면 된다.

```JAVA
@Test
@DirtiesContext // 다이나믹 프록시 팩토리 빈을 직접 만들어 사용할 때는 없앴다가 다시 등장한 컨텍스트 무효화 어노테이션
public void upgradeAllOrNothing() throws Exception {
	MockMailSender mailSender = new MockMailSender();
		
	UserServiceImple testUserService = new UserServiceImple(users.get(3).getId());
	testUserService.setUserDao(userDao);
	testUserService.setMailSender(mailSender);
		
	TxProxyFactoryBean txProxyFactoryBean = context.getBean("&userService", TxProxyFactoryBean.class);
	txProxyFactoryBean.setTarget(testUserService);
	UserService txUserService = (UserService) txProxyFactoryBean.getObject(); // 변경된 타깃 설정을 이용해서 트랜잭션 다이나믹 프록시 오브젝트를 다시 생성한다.
		
	userDao.deleteAll();
	for (User user : users) userDao.add(user);
		
	try {
		txUserService.upgradeLevels();
		fail("TestUserServiceException expected");
	} catch (Exception e) {
	}
		
	checkLevel(users.get(1), false);
}
```

### 프록시 팩토리 빈 방식의 장점과 한계
한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있는 장점이 있다.

##### 프록시 팩토리 빈의 재사용
```JAVA
트랜잭션 없는 서비스 빈 설정
<bean id="coreService" class="OOO.OOO.CoreServiceImple">
	<property name="coreDao" ref="coreDao" />
</bean>
-----------------------------------------------------------------------------

아이디를 변경한 CoreService 빈
<bean id="coreServiceTarget" class="OOO.OOO.CoreServiceImple">
	<property name="coreDao" ref="coreDao" />
</bean>

프록시 팩토리 빈 DI
<bean id="userService" class="practice.spring.toby.chapter6.TxProxyFactoryBean">
	<property name="target" ref="coreServiceTarget" /> // 수정자 메서드를 통한 의존성 주입
	<property name="target" ref="userServiceImple" />
	<property name="transactionManager" ref="transactionManager" />
	<property name="pattern" value="upgradeLevels" />
	<property name="serviceInterface" value="practice.spring.toby.chapter6.UserService" />
</bean>
```

위에처럼 처리하게 되면 coreService에 존재하는 모든 메서드를 imple에서 생성해줘야하는 불편함이 존재하지만 아래처럼 ProxyFactoryBean을 사용하게 되면 부가기능만 재정의 해주면 나머지는 알아서 처리된다. 코드 한줄 만들지 않고 기존 코드에 부가적인 기능을 추가해줄 수 있다는 건 정말 매력적인 방법이 아닐 수 없다.

##### 장점
- 다이나믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
- 하나의 핸들러 메서드를 구현하는 것으로 수많은 메서드에 부가기능을 부여해줄 수 있으니 부가기능 코드의 중복 문제도 사라진다.
- 프록시에 팩토리 빈을 이용한 DI까지 더해주면 번거로운 다이나믹 프록시 생성 코드도 제거할 수 있다.
- DI 설정만으로 다양한 타깃 오브젝트에 적용도 가능하다.

##### 프록시 팩토리 빈의 한계
하나의 타깃 (클래스) 안에 존재하는 여러 개의 메서드에 부가기능을 한 번에 제공하는 것은 쉽게 가능했다. 하지만 여러개의 타깃 (클래스) 에 하나의 부가기능을 적용하는 것은 쉽지 않다. 한 가지 예로 다양한 타깃에 트랜잭션 (부가기능)을 프록시 팩토리로 중복없이 처리하긴 쉽지 않다. 또 한가지 문제점은 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다는 점이다. TransactionHandler는 타깃 오브젝트를 프로퍼티로 갖고 있다. 따라서 트랜잭션 부가기능을 제공하는 동일한 코드임에도 불구하고 타깃 오브젝트가 달라지면 새로운 TransactionHandler 오브젝트를 만들어야 한다. 이제 이 문제를 스프링의 프록시 팩토리 빈에서 해결할 것이다.

### 스프링의 프록시 팩토리 빈

##### ProxyFactoryBean
자바에는 JDK에서 제공하는 다이나믹 프록시 외에도 편리하게 프록시를 만들 수 있도록 지원해주는 다양한 기술이 존재한다. 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다. 스프링의 ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다. ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다. InvocationHandler와 비슷하지만 다른 점은 InvocationHandler의 invoke() 메서드는 타깃 오브젝트에 대한 정보를 제공하지 않는다. 따라서 InvocationHandler가 구현한 클래스가 직접 알고 있어야 한다.

```JAVA
// JDK의 다이나믹 프록시
@Test
public void simpleProxy() {
	Hello proxiedHello = (Hello) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] {Hello.class}, new UppercaseHandler(new HelloTarget()));
	
	assertThat(proxiedHello.sayHello("Kim"), is("HELLO KIM"));
	assertThat(proxiedHello.sayHi("Kim"), is("HI KIM"));
	assertThat(proxiedHello.sayThankYou("Kim"), is("THANK YOU KIM"));
}

// 스프링의 ProxyFactoryBean	
@Test
public void proxyFactoryBean() {
	ProxyFactoryBean pfBean = new ProxyFactoryBean();
	pfBean.setTarget(new HelloTarget()); 				// 타깃 설정
	pfBean.addAdvice(new UppercaseAdvice());			// 부가기능 설정
	
	Hello proxiedHello = (Hello) pfBean.getObject();	// FactoryBean이므로 getObject()로 생성된 프록시를 가져온다.
	
	assertThat(proxiedHello.sayHello("Kim"), is("HELLO KIM"));
	assertThat(proxiedHello.sayHi("Kim"), is("HI KIM"));
	assertThat(proxiedHello.sayThankYou("Kim"), is("THANK YOU KIM"));
}

// 부가기능
static class UppercaseAdvice implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		// 리플렉션의 Method와 달리 메서드가 실행 시 타깃 오브젝트를 전달할 필요가 없다. MethodInvocation은 메서드 정보와 함께 타깃 오브젝트를 알고 있기 때문이다.
		String ret = (String) invocation.proceed();
		return ret.toUpperCase();
	}
}

```

##### 어드바이스 : 타깃이 필요없는 순수한 부가기능 (MethodInvocation)
MethodInvocation은 일종의 콜백 오브젝트로, proceed() 메서드를 실행하면 타깃오브젝트의 메서드를 내부적으로 실행해주는 기능이 있다. MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작하는 것이다. 바로 이 점이 JDK의 다이나믹 프록시를 직접 사용하는 코드와 스프링이 제공해주는 프록시 추상화 기능인 ProxyFactoryBean을 사용하는 코드의 가장 큰 차이점이자 ProxyFactoryBean의 장점이다.
ProxyFactoryBean은 작은단위의 템플릿/콜백 패턴의 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다. 마치 SQL파라미터 정보에 종속되지 않는 JDBCTemplate이기 때문에 수많은 DAO 메서드가 하나의 JDBCTemplate 오브젝트를 공유할 수 있는 것과 마찬가지다. 또한 MethodInterceptor를 설정해줄 때는 일반적인 DI 경우 처럼 수정자 메서드를 사용하지 않고 addAdvice() 라는 메서드를 사용한다는 점도 눈여겨 봐야 한다. ProxyFactoryBean 하나로 여러개의 MethodInterceptor를 추가할 수 있다. 
타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 스프링에선 어드바이스 (Advice) 라고 부른다.
그리고 JDK의 다이나믹 프록시의 경우 타깃의 인터페이스 정보를 지정해줬지만 ProxyFactoryBean는 인터페이스 타입을 제공받지도 않고 구현이 됐는데 ProxyFactoryBean에는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.

##### 포인트 컷 : 부가기능 적용 대상 메서드 선정 방법
기존 InvocationHandler는 pattern이라는 스트링 변수로 메서드 이름을 받아 비교해서 부가기능을 적용 대상으로 판별했다. MethodInterceptor의 경우 여러 프록시가 공유해서 사용하기 때문에 타깃 정보를 갖고 있지 않도록 만들어졌다. 그 덕분에 스프링의 싱글톤 빈으로 등록할 수 있었다. 그럼 부가기능을 특정 메서드만 사용하게 하는 방법은 코드를 분리해주면 된다. MethodInterceptor는 프록시가 클라이언트로부터 받는 요청을 일일이 전달받을 필요는 없다. MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남겨주는 것이다.
스프링은 부가기능을 제공하는 오브젝트를 어드바이스라고 부르고, 메서드 선정 알고리즘을 담은 오브젝트를 포인트컷이라고 부른다. 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다. 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.

##### Flow
1. 프록시는 클라이언트로 요청을 받으면 포인트컷에게 부가기능을 부여할 메서드인지 확인해달라고 요청한다. (PointCut 인터페이스를 구현해서 만든다.)
2. 프록시는 포인트컷으로부터 부가기능을 적용할 대상 메서드인지 확인을 받으면, MethodInterceptor 타입의 어드바이스를 호출한다.
3. 어드바이스는 JDK의 다이나믹 프록시의 InvocationHandler와 달리 직접 타깃을 호출하지 않는다. (자신이 공유돼야 하므로 타깃 정보라는 상태를 가질 수 없다.)
4. 어드바이스가 부가기능을 부여하는 중에 타깃 메서드의 호출이 필요하면 프록시로부터 전달받은 MethodInvocation 타입 콜백 오브젝트의 proceed() 메서드를 호출해주기만 하면 된다.

실제 위임 대상인 타깃 오브젝트의 레퍼런스를 갖고 있고, 이를 이용해 타깃 메서드를 직접 호출하는 것은 프록시가 메서드 호출에 따라 만드는 Invocation 콜백의 역할이다. 재사용 가능한 기능을 만들어두고 바뀌는 부분(콜백 오브젝트와 메서드 호출정보)만 외부에서 주입해서 이를 작업 흐름(부가기능부여) 중에 사용하도록 하는 전형적인 템플릿/콜백 구조다. 어드바이스가 일종의 템플릿이 되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜백이 되는 것이다.

```JAVA
@Test
public void pointcutAdvisor () {
	ProxyFactoryBean pfBean = new ProxyFactoryBean();
	pfBean.setTarget(new HelloTarget()); 				
	
	// 메서드 이름을 비교해서 대상을 선정하는 알고리즘을 제공하는 포인트컷
	NameMatchMethodPointcut pointCut = new NameMatchMethodPointcut(); 
	pointCut.setMappedName("sayH*");
	
	// 포인트컷과 어드바이스를 Advisor로 묶어서 한번에 추가
	pfBean.addAdvisor(new DefaultPointcutAdvisor(pointCut, new UppercaseAdvice()));
	
	Hello proxiedHello = (Hello) pfBean.getObject();	
	
	assertThat(proxiedHello.sayHello("Kim"), is("HELLO KIM"));
	assertThat(proxiedHello.sayHi("Kim"), is("HI KIM"));
	assertThat(proxiedHello.sayThankYou("Kim"), is("Thank You Kim")); // 메서드 이름이 포인트컷의 선정조건에 맞지 않으므로 부가기능이 적용되지 않는다.
}
```

포인트컷이 필요 없을 때는 ProxyFactoryBean의 addAdvice() 메서드를 호출해서 어드바이스만 등록하면 됐다. 포인트컷을 함께 등록할 때는 어드바이스와 포인트컷을 advisor 타입으로 묶에서 addAdvisor() 메서드를 호출해야 한다. advisor 타입으로 묶어서 추가하는 이유는 ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문이다. (원하는 부가기능과 메서드를 조합해야하기 때문이다.)
이렇게 어드바이스와 포인트컷을 담은 오브젝트를 어드바이저라고 부른다.
어드바이저 = 어드바이스(부가기능) + 포인트컷(메서드 선정알고리즘)

##### Transaction Advice
MethodInterceptor 인터페이스를 통한 구현을 하게되면 InvocationHandler를 통한 구현을 할 때보다 조금 더 간결하다. InvocationHandler의 리플렉션을 통한 타깃 메서드 호출 작업의 번거로움을 MethodInvocation 타입의 콜백을 이용한 덕분에 대부분 제거할 수 있다. 타깃 메서드가 던지는 예외도 포장되서 오는 것이 아니기 때문에 예외 그대로 throw를 통한 처리가 가능하다.

##### 어드바이스와 포인트컷의 재사용
ProxyFactoryBean 은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다. 그 덕분에 독립적이며, 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다. 메서드 선정을 위한 포인트컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록해주면 된다. 트랜잭션을 이용할 메서드의 경우에도 ***Transaction 등 명명 규칙을 정해두면 하나의 포인트컷으로 충분할 수 있다.

### 스프링 AOP

##### 자동 프록시 생성
새로운 타깃이 등장했다고 해서 코드를 손댈 필요는 없어졌지만, 설정은 매번 복사해서 붙이고 target 프로퍼티의 내용을 수정해줘야 한다. 하루 만에 수천 개의 ProxyFactoryBean 설정을 추가할 수 있을 만큼 단순하고 쉬운 일이지만, 단순하고 쉬운 작업인 만큼 실수하기도 쉽다. target 프로퍼티를 제외하면 빈 클래스의 종류, 어드바이스, 포인트컷의 설정이 동일하다.

##### 중복 문제의 접근 방법
앞서 다루었던 반복적인 코드의 해결책을 생각해보자.
1. JDBC API를 사용하는 DAO코드 내에서 메서드마다 JDBC try/catch/finally 블록으로 구성된 비슷한 코드가 있었을 때 정적 코드와 동적코드를 나누어서 템플릿/콜백 패턴을 통해 깔끔해게 해결했다. 전략 패턴과 DI를 적용한 해결책이었다.
2. 이와는 좀 다른 방법으로 해결된 문제는 프록시 클래스 코드이다. 타깃 오브젝트로의 위임 코드와 부가기능 적용을 위한 코드가 프록시가 구현해야 하는 모든 인터페이스 메서드마다 반복적으로 필요했다. 다이나믹 프록시라는 런타임 코드 자동생성 기법을 이용하였다. 변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단이라는 부분은 코드 생성 기법을 이용하는 다이나믹 프록시 기술에 맡기고, 변하는 부가기능 코드는 별도로 만들어서 다이나믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용하였다.

##### 빈 후처리기를 이용한 자동 프록시 생성기
스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다. 그 중 관심을 가질 확장 포인트는 BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기이다. 빈 후처리기는 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다. 빈 후처리기를 적용하는 방법은 빈 후처리기 자체를 빈으로 등록하는 것이다. 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다. 

빈 후처리기 플로우
1. 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.
2. DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
3. 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
4. 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다.
5. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

##### 확장된 포인트컷
포인트컷에는 타깃 오브젝트의 메서드중에서 어떤 메서드에 부가기능을 적용할 지 선정해주는 역할과 등록된 빈 중에서 어떤 빈에 프록시를 적용할지에 대한 기능을 갖고 있다. 포인트컷은 클래스 필터와 메서드 매처 두 가지를 돌려주는 메서드를 갖고 있다. ProxyFactoryBean에서는 타깃을 정하기 때문에 프록시를 적용할 클래스인지 확인하지 않았지만, 모든 빈에 대해 프록시 자동 적용 대상을 선별해야 하는 빈 후처리기인 DefaultAdvisorAutoProxyCreator는 클래스와 메서드 선정 알고리즘을 모두 갖고 있는 포인트컷이 필요하다. 정확히는 그런 포인트컷과 어드바이스가 결합되어 있는 어드바이저가 등록되어 있어야 한다.

```JAVA
public interface Pointcut {
	ClassFilter getClassFilter();			// 프록시를 적용할 클래스인지 확인해준다.
	MethodMatcher getMethodMatcher();		// 어드바이스를 적용할 메서드인지 확인해준다.
}
```

##### 어드바이저를 이용하는 자동 프록시 생성기 등록
DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다. 그리고 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다. 빈 클래스가 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기한다. 원래 빈 오브젝트는 프록시 뒤에 연결되어 프록시를 통해서만 접근 가능하게 바뀌는 것이다.

```JAVA
<!-- DefaultAdvisorAutoProxyCreator 등록 -->
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" />
```
이 빈은 id애트리뷰트가 없고 클래스 뿐이다. 다른 빈에서 참조되거나 코드에서 빈 이름으로 조회할 필요가 없는 빈이라면 아이디를 등록하지 않아도 무방하다.

##### 자동생성 프록시 확인
트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 메커니즘을 통해 적용했을 때 최소 두 가지는 확인해야 한다.
1. 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용되었는지.
- 트랜잭션이 정상적으로 커밋되는 경우에는 트랜잭션 적용 여부를 확인하기 힘들기 때문에 예외상황에서 트랜잭션이 롤백되게 함으로써 트랜잭션 적용 여부를 테스트해야 한다.
2. 아무 빈에나 트랜잭션이 부가기능이 적용된 것은 아닌지 확인해야 한다.
- 프록시 자동생성기가 어드바이저 빈에 연결해둔 포인트컷의 클래스 필터를 이용해서 정확히 원하는 빈에만 프록시를 생성했는지 확인이 필요하다. 즉 클래스 필터가 제대로 동작해서 프록시 생성 대상을 선별하고 있는지 여부를 알고 싶은 것이다. 방법은 간단하다. 포인트컷의 빈의 클래스 이름 패턴을 변경해서 앞선 테스트를 적용되지 않게 해보면 된다.

##### 포인트컷 표현식
포인트컷 표현식이란 포인트컷의 클래스와 메서드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공하는 것이다. 정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법이다. 포인트컷 표현식을 지원하는 포인트컷을 적용하려면 AspectJExpressionPointcut 클래스를 사용하면 된다. Pointcut 인터페이스를 구현해야 하는 스프링의 포인트컷은 클래스 선정을 위한 필터와 메서드 선정을 위한 메서드 매처 두 가지를 각각 제공해야 한다. 하지만 AspectJExpressionPointcut은 클래스와 메서드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다.

##### 포인트컷 표현식 문법
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다. 포인트컷 지시자 중 가장 많이 사용되는 것은 execution()이다. 문법구조는 기본적으로 다음과 같다. [] 괄호는 옵션항목이기 때문에 생략이 가능하다. | 는 OR 조건이다. 메서드의 풀 시그니처를 문자열로 비교하는 개념이라고 생각하면 간단하다.

- 접근제한자 : public, protected, private 등이 올 수 있다. 포인트컷 표현식에서는 생략이 가능하다.
- 리턴 타입 : 포인트컷 표현식에서 리턴 값의 타입 패턴은 필수 항목이다. 하나의 타입을 지정하던가 *를 사용하여 모든 타입을 선택할 수 있다. 생략은 불가능하다.
- 패키지와 타입 이름을 포함한 클래스 타입 : 생략가능하다.  생략 시 모든 타입을 허용하겠다는 의미이다. 이름에 * 또는 '..'를 사용하면 한번에 여러 개의 패키지를 선택할 수 있다.
- 메서드 이름 패턴 : 필수항목이다. 모든 메서드를 선택하고싶다면 *를 사용한다.
- 메서드 파라미터 타입 : 메서드 파라미터의 타입 패턴이다. 타입을 ','로 구분하면서 순서대로 적으면 된다. 파라미터가 없는 메서드를 지정하고 싶다면 ()로 적는다. 파라미터 타입과 개수에 상관없이 모두 허용하려면 '..'를 넣으면 된다. '...'을 이용해서 뒷부분의 파라미터 조건만 생략할 수도 있다. 필수항목이다.
- 예외 이름에 대한 타입 패턴 : 생략 가능하다.

포인트컷 표현식은 메서드의 시그니처를 비교하는 방식인 execution() 외에도 몇 가지 표현식 스타일을 갖고 있다. 대표적으로 스프링에서 사용될 때 빈의 이름으로 비교하는 bean()이 있다. bean(*service)라고 적으면 서비스로 끝나는 모든 빈을 선택한다. 또 특정 어노테이션 타입, 메서드, 파라미터에 적용되어 있는 것을 보고 메서드를 선정하게 하는 포인트컷도 만들 수 있다. 
@annotation(org.springframework.transaction.annotation.Transactional)

##### 타입 패턴과 클래스 이름 패턴
클래스 이름 패턴과 포인트 컷 표현식에서 사용하는 타입 패턴은 중요한 차이점이 있다. 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴이기 때문이다. 때문에 앞서 테스트 하였던 TestUserServiceImple -> TestUserService로 변경하더라도 성공적인 결과를 가져온다. 타입을 따져보면 TestUserService은 UserServiceImple의 자식클래스이면서 UserService 인터페이스의 구현클래스이다. 세 가지 타입 모두 적용되는 것이다.

### AOP란 무엇인가?
##### 트랜잭션 서비스 추상화
트랜잭션 적용이라는 추상적인 작업 내용을 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법. 구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이나믹하게 연결해준다는 DI를 활용한 전형적인 접근 방법이다. 트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지는 남기고, 그것을 어떻게 하는지를 분리한 것이다. 어떻게 할지는 더 이상 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 됐다.

##### 프록시와 데코레이터 패턴
투명한 부가기능 부여를 가능하게 하는 데코레이터 패턴의 적용 덕에 비즈니스 로직을 담당하는 클래스도 자신을 사용하는 클라이언트와 DI 관계를 맺을 이유를 찾게 됐다. 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만들었다. 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨서, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었다. 클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 됐다.

##### 다이나믹 프록시와 프록시 팩토리 빈
프록시를 이용해서 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거할 수 있었지만, 비즈니스 로직 인터페이스의 모든 메서드에 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만들거나, 트랜잭션 기능을 부여하지 않아도 인터페이스의 메서드를 모두 구현해줘야 했다. 그래서 프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이나믹 프록시 (InvocationHandler) 기술을 적용했다. 하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로 중복이 일어나는 문제를 JDK 다이나믹 프록시 기술에선 해결하지 못했다. 이 문제는 스프링의 프록시 팩토리빈을 이용해서 다이나믹 프록시 생성 방법에 DI를 도입했다. 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어디바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용할 수 있게 됐다.

##### 자동 프록시 생성 방법과 포인트컷
트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담이 남아 있었다. 이를 해결하기 위해 스프링 컨테이너의 빈 후처리기 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다. 패턴을 통해 자동으로 프록시 대상 오브젝트를 선정하는 기능을 가진 확장된 포인트 컷을 사용했다. 최종적으로 포인트컷 표현식의 AspectJExpressionPointcut.execution() 메서드를 활용해 표현식을 작성하여 특정 대상을 선정하는 편리하고 깔끔한 방법을 활용했다.

##### 부가기능의 모듈화
트랜잭션 적용 코드는 기존에 써왔던 방법으로는 간단하게 분리해서 독립된 모듈로 만들 수가 없었다. 왜냐하면 트랜잭션 경계설정 기능은 다른 모듈의 코드에 부가적으로 부여되는 기능이라는 특징이 있기 때문이다. 따라서 트랜잭션 경계설정 기능을 독립된 모듈로 만들려면 특별한 기법이 필요하다. 클래스를 만들지 않고도 새로운 구현 기능을 가진 다이나믹 프록시라던가 IoC/DI 컨테이너의 빈 생성 작업을 가로채서 빈 오브젝트를 프록시로 대체하는 빈 후처리기 기술과 같은 복잡한 기술이 요구된다. 
트랜잭션 부가기능이란 트랜잭션 기능을 추가해줄 다른 대상, 즉 타깃이 존재해야만 의미가 있다. 부가기능은 여타 핵심기능과 같은 레벨에서는 독립적으로 존재하는 것 자체가 불가능하다. 부가기능 트랜잭션 경계설정 기능은 TransactionAdvice라는 이름으로 모듈화될 수 있었다. 모듈화되어 있기 때문에 중복되지 않으며, 변경이 필요하면 한 곳만 수정하면 된다. 또한 포인트컷이라는 방법을 통해 부가기능을 부여할 대상을 선정할 수 있다. 핵심기능과 부여되는 부가기능을 효과적으로 모듈화하는 방법은 어드바이스와 포인트컷을 결합한 어드바이저이다.

##### AOP: 애스펙트 지향 프로그래밍
에스펙트란 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다. 애스펙트는 부가될 기능을 정의한 코드인 어드바이스와 어드바이스를 어디에 적용할지 결정하는 포인트컷을 함께 갖고 있다. 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특학 모듈로 만들어서 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍 또는 약자로 AOP라고 부른다. AOP는 OOP를 돕는 보조적인 기술이지 OOP를 대체하는 새로운 개념은 아니다.

### AOP 적용기술
##### 프록시를 이용한 AOP
스프링은 IoC/DI 컨테이너와 다이나믹프록시, 데코레이터 패턴, 프록시패턴, 자동 프록시 생성 기법, 빈 오브젝트의 후처리 조작 기법 등의 다양한 기술을 조합해 AOP를 지원하고 있다. 그 중 가장 핵심은 프록시를 이용했다는 것이다. 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않는다. 스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메서드다. 프록시 방식을 사용했기 때문에 메서드 호출 과정에 참여해서 부가기능을 제공해주게 되어 있다. 이러한 스프링AOP의 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메서드에 다이나믹하게 적용해주는 가장 중요한 역할을 하는 게 프록시다. 그래서 스프링AOP는 프록시 방식의 AOP라고 할 수 있다.

##### 바이트코드 생성과 조작을 통한 AOP
프록시 방식이 아닌 AOP중 가장 강력한 AOP프레임워크는 AspectJ이다. 스프링도 AspectJ의 포인트컷 표현식을 차용해서 사용할 만큼 매우 성숙하고 발전한 AOP기술이다. AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다. 타깃 오브젝트의 소스코드를 수정할 수 없으니, 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.

##### AspectJ는 프록시같은 방법이 있음에도 컴파일된 클래스 파일 수정이나 바이트코드 조작과 같은 복잡한 방법을 사용하는 두 가지 이유
1. 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문이다. 환경에 구애를 받지 않는다.
2. 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다. 프록시를 AOP 핵심 매커니즘으로 사용하면 클라이언트가 호출할 때 사용하는 메서드로 제한된다. 반면 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다. 또 프록시 적용이 불가능한 priavate 메서드의 호출, 스태틱 메서드 호출이나 초기화, 심지어 필드 입출력 등에 부가기능을 부여하려고 하면 클래스 바이트코드를 직접 조작해서 타깃 오브젝트나 호출 클라이언트의 내용을 수정하는 것밖에는 방법이 없다.

단점으로는 AspectJ 같은 고급 AOP 기술은 바이트코드 조작을 위해 JVM의 실행 옵션을 변경하거나, 별도의 바이트코드 컴파일러를 사용하거나, 특별한 클래스 로더를 사용하게 하는 등의 번거로운 작업이 필요하다. 때문에 일반적인 AOP를 적용하는 데는 프록시 방식의 스프링 AOP로도 충분하다. 특별한 AOP요구사항이 생겨 스프링 AOP로 해결되지 않을 때 AspectJ의 AOP를 사용하면 된다.

### AOP의 용어
- 타깃 : 타깃은 부가기능을 부여할 대상이다. 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.
- 어드바이스 : 어드바이스는 타깃에게 제공할 부가기능을 담은 모듈이다. 어드바이스는 오브젝트로 정의하기도 하지만 메서드 레벨에서 정의할 수도 있다.
- 조인 포인트 : 조인 포인트란 어드바이스가 적용될 수 있는 위치를 말한다. 스프링의 프록시 AOP에서 조인포인트는 메서드의 실행 단계뿐이다. 타깃 오브젝트가 구현한 인터페이스의 모든 메서드는 조인 포인트가 된다.
- 포인트컷 : 포인트컷이란 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다. 스프링의 포인트컷은 메서드를 선정하는 기능을 갖고 있다. 그래서 포인트컷 표현식은 메서드의 실행이라는 의미인 execution으로 시작하고, 메서드의 시그니처를 비교하는 방법을 주로 이용한다.
- 프록시 : 프록시는 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트다. DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메서드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여한다.
- 어드바이저 : 어드바이저는 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다. 어드바이저는 어떤 부가기능(어디바이스)를 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈이다.스프링 AOP에서만 사용되는 특별한 용어이고, 일반적인 AOP에서는 사용되지 않는다.
- 애스펙트 : OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈이다. 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다. 스프링의 어드바이저는 가장 단순한 애스펙트라고 볼 수 있다.

##### AOP 네임스페이스
스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 애플리케이션의 로직을 담은 UserDao나 UserService 빈과는 성격이 다르다. 이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해서 사용된다. 스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.
- 자동 프록시 생성기 : 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을 DI하지도 않고 자신도 DI 되지않으며 독립적으로 존재한다. 따라서 id도 굳이 필요하지 않는다. 애플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에서 빈 후처리기로 참여한다. 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.
- 어드바이스 : 부가기능을 구현한 클래스를 빈으로 등록한다. TransactionAdvice는 AOP 관련 빈중에서 유일하게 직접 구현한 클래스를 사용한다.
- 포인트컷 : 스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다. 코드를 작성할 필요는 없다.
- 어드바이저 : 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능은 없다. 자동 프록시 생성기에 의해 자동 검색되어 사용된다.

이 중 부가기능을 담은 코드로 만든 어드바이스를 제외한 나머지 세 가지는 모두 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것이다.

- AOP 네임스페이스 : 스프링은 AOP와 관련된 태그를 정의해둔 aop 스키마를 제공한다. 사용하려면 설정파일에 aop네임스페이스 선언을 .xml 추가해줘야 한다.

```JAVA
// AOP 설정을 담는 부모 태그다. 필요에 따라 AspectJAdvisorAutoProxyCreator를 빈으로 등록해준다.
<aop:config>
	// expression의 표현식을 프로퍼티로 가진 AspectJExpressionPointcut을 빈으로 등록해준다.
	<aop:pointcut expression="execute(* *..*ServiceImple.upgrade*(..))" id="transactionPointcut"/> 

	// advice와 pointcut의 ref를 프로퍼티로 갖는 DefaultBeanFactoryPointcutAdvisor를 등록해준다.
	<aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut"/>	
</aop:config>
```

<aop:config>, <aop:pointcut>, <aop:advisor> 세 가지 태그를 정의해두면 그에 따라 세 개의 빈이 자동으로 등록된다. 애플리케이션을 구성하는 컴포넌트 빈과 컨테이너에 의해 사용되는 기반 기능을 지원하는 빈은 구분이 되는 것이 좋다.

- 어드바이저 내장 포인트컷
하나의 포인트컷을 여러 개의 어드바이저에 공유할 때는 위의 방법처럼 aop:pointcut 태그를 사용하여 따로 분리하여 등록해두는 것이 중복 부분에서 더 좋다.
포인트컷을 내장하는 경우에는 aop:advisor 태그 하나로 두 개의 빈이 등록된다. (내장, 외부에서 등록한 빈)
```JAVA
// 포인트컷을 내장한 어드바이저 태그
<aop:config>
	<aop:advisor advice-ref="transactionAdvice" pointcut="execute(* *..*ServiceImple.upgrade*(..))" />	
</aop:config>
```

### 트랜잭션 속성
##### 트랜잭션 정의
트랜잭션이라고 모두 같은 방식으로 동작하는 것은 아니다. 물론 트랜잭션의 기본 개념인 더 이상 쪼갤 수 없는 최소 단위의 작업이라는 개념은 항상 유효하다. 따라서 트랜잭션 내의 모든 작업은 commit 혹은 rollback를 통해 결과를 처리해야 한다. 이 밖에도 트랜잭션의 동작방식을 제어할 수 있는 몇 가지 조건이 있다. DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다.

- 트랜잭션 전파 : 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.
	
1. PROPAGATION_REQUIRED
가장 많이 사용되는 트랜잭션 전파 속성이다. 진행중인 트랜잭션이 없으면 새로 시작하고, 진행중인 트랜잭션이 있을경우 이에 참여한다. PROPAGATION_REQUIRED 트랜잭션 전파 속성을 갖는 코드는 다양한 방식으로 결합해서 하나의 트랜잭션으로 구성하기 쉽다. A, B 가 모두 PROPAGATION_REQUIRED로 선언되어 있다면 A, B, A->B, B->A와 같은 네 가지 조합된 트랜잭션이 모두 가능하다. DefaultTransactionDefinition의 트랜잭션 전파 속성도 바로 이것이다.

2. PROPAGATION_REQUIRES_NEW
항상 새로운 트랜잭션을 시작한다. 즉 앞에서 시작된 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작하게 한다. 독립적으로 트랜잭션이 보장돼야 하는 코드에 적용할 수 있다.

3. PROPAGATION_NOT_SUPPORTED
이 속성을 사용하면 트랜잭션 없이 동작하도록 만들 수도 있다. 트랜잭션을 무시하는 속성을 두는 데는 이유가 있다. AOP를 이용해 트랜잭션을 사용할 때 한번에 많은 메서드를 트랜잭션 처리하게 된다. 하지만 그 중 특별하게 트랜잭션의 영향을 받지 않도록 해야하는 메서드가 있을경우 사용할 수 있다.

트랜잭션 매니저를 통해 트랜잭션을 시작하려고 할 때 getTransaction()이라는 메서드를 사용하는 이유는 바로 트랜잭션 전파 속성이 있기 때문이다. 항상 트랜잭션을 새로 시작하는 것이 아니고 전파 속성과 현재 진행중인 트랜잭션이 존재하는지 여부에 따라서 새로운 트랜잭션을 시작할 수도 있고, 이미 생성된 트랜잭션에 참여하기만 할 수도 있다.

##### 격리수준
모든 DB 트랜잭션은 격리수준을 갖고 있어야 한다. 서버환경에서는 여러개의 트랜잭션이 동시에 진행될 수 있다. 따라서 적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요하다. 격리수준은 기본적으로 DB에 설정되어 있지만 JDBC 드라이버나 DataSource에서 재설정할 수도 있고, 필요하다면 트랜잭션 단위로 격리수준을 조정할 수도 있다.

##### 제한시간
트랜잭션을 수행하는 제한시간을 설정할 수 있다. DefaultTransactionDefinition의 기본 설정은 제한시간이 없다. 제한시간은 트랜잭션을 직접 사용할 수 있는 PROPAGATION_REQUIRED나 PROPAGATION_REQUIRES_NEW와 함께 사용해야만 의미가 있다.

##### 읽기 전용
읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다. TransactionDefinition을 생성하고 사용하는 코드는 트랜잭션 경계설정 기능을 가진 TransactionAdvice다. 트랜잭션 정의를 바꾸고 싶다면 DefaultTransactionDefinition이 아닌 외부에서 정의된 TransactionDefinition 오브젝트를 DI 받아서 사용하도록 만들면 된다. 이렇게 정의를 변경하면 TransactionAdvice을 사용하는 모든 트랜잭션 속성이 한꺼번에 바뀌는 문제점이 있다. 

#### 트랜잭션 인터셉터와 트랜잭션 속성
메서드 별 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 한다. 마치 초기에 TransactionHandler를 이용해 트랜잭션 적용 여부를 판단 했던 것과 비슷한 방식을 사용하면 된다. 메서드 이름 패턴에 따라 다른 트랜잭션을 적용 되도록 만드는 것이다.

##### TransactionInterceptor
메서드 이름패턴으로 트랜잭션을 설정할 때 TransactionAdvice를 다시 설계할 필요가 없다. 스프링에는 트랜잭션 경계설정 어드바이스로 사용할 수 있도록 만들어진 TransactionInterceptor가 존재하기 때문이다.
TransactionInterceptor 어드바이스의 동작방식은 기존에 만들었던 TransactionAdvice와 다르지않다. 다만 트랜잭션 정의를 메서드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공해줄 뿐이다.
TransactionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있다. Properties 타입인 두 번째 프로퍼티 이름은 transactionAttributes로 트랜잭션 속성을 정의한 프로퍼티다.

TransactionInterceptor 5가지 속성
1. 트랜잭션 전파 : 어떤 트랜잭션이 동작중인 과정에서 다른 트랜잭션을 실행할 경우 '어떻게 처리하는가'에 대한 개념이다.
2. PROPAGATION_REQUIRED : 진행중인 트랜잭션이 없으면 새로 시작하고 있으면 참여한다.
3. PROPAGATION_REQUIRES_NEW : 항상 새로운 트랜잭션을 시작한다.
4. PROPAGATION_NOT_SUPPORTED : 트랜잭션 없이 동작한다.
5. rollbackOn() : 어떤 예외가 발생하면 롤백을 할 것인가를 결정하는 메서드다. TransactionAttribute를 이용하면 트랜잭션 부가기능의 동작 방식을 모두 제어할 수 있다.

TransactionAdvice는 RuntimeException이 발생하는 경우에만 트랜잭션을 롤백시킨다. 체크 예외를 던지는 타깃에 사용한다면 문제가 될 수 있다. 그렇다고 모든 예외를 롤백시키는 것은 안된다. 비즈니스 로직상의 예외 경우를 나타내기 위해 타깃 오브젝트가 체크 예외를 던지는 경우에는 DB 트랜잭션을 커밋시켜야 하기 때문이다.

스프링이 제공하는 TransactionInterceptor에는 기본적으로 두 가지 종류의 예외 처리 방식이 있다. 런타임 예외가 발생하면 트랜잭션은 롤백된다. 반면 타깃 메서드가 런타임 예외가 아닌 체크예외를 던질 시 이것을 예외상황으로 해석하지 않고 트랜잭션 커밋을 진행한다. 그런데 TransactionInterceptor의 예외처리 기본원칙을 따르지 않는 경우가 있다. TransactionAttribut는 rollbackOn() 이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해준다. TransactionInterceptor는 이런 TransactionAttribute를 Properties라는 일종의 맵 타입 오브젝트로 전달받는다. 컬렉션을 사용하는 이유는 메서드 패턴에 따라서 각기 다른 트랜잭션 속성을 부여할 수 있게 하기 위해서다.

##### 메서드 이름 패턴을 이용한 트랜잭션 속성 지정
- PROPAGATION_NAME : 트랜잭션 전파 방식, 필수항목이다. PROPAGATION_로 시작한다.
- ISOLATION_NAME : 격리수준, ISOLATION_로 시작한다. 생략가능하다. (Default : 격리수준)
- readOnly : 읽기 전용 항목. 생략 가능하다. (Default : null)
- timeout_NNNN : 제한시간, timeout_로 시작하고 초 단위 시간을 뒤에 붙인다. 생략가능.
- -Exception1 : 체크예외 중에서 롤백 대상으로 추가할 것을 넣는다. (복수가능)
- +Exception2 : 런타임 예외지만 롤백시키지 않을 예외들을 넣는다. (복수가능)
이 중에서 트랜잭션 전파 항목만 필수고 나머지는 다 생략 가능하다. 생략하면 모두 DefaultTransactionDefinition에 설정된 디폴트 속성이 부여된다.

```JAVA
트랜잭션 속성 정의 예
<bean id="transactionAdvice" class="org.springframework.transaction.interceptor.TransactionInterceptor">
	<property name="transactionManager" ref="transactionManager"/>
	<property name="transactionAttributes">
		<props>
			<prop key="get*">PROPAGATION_REQUIRED,readOnly,timeout_30</prop>
			<prop key="upgrade*">PROPAGATION_REQUIRES_NEW,ISOLATION_SERIALIZABLE</prop>
			<prop key="*">PROPAGATION_REQUIRED</prop>
		</props>
	</property>
</bean>
```

##### tx네임스페이스를 이용한 설정방법
TransactionInterceptor 타입과 TransactionAttribute타입의 속성 정보도 tx스키마의 전용 태그를 이용해 정의할 수 있다.

```JAVA
 <beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema.beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx-2.5.xsd">

    // 이 태그에 의해 TransactionInterceptor 빈이 등록된다.
    <tx:advice id="transactionAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="get*" propagation="REQUIRED" read-only="true" timeout="30" />
	<tx:method name="upgrade*" propagation="REQUIRES_NEW" isolation="SERIALIZABLE" />
	<tx:method name="*" propagation="REQUIRED" />
        </tx:attributes>
    </tx:advice>
```

bean 태그로 등록하는 경우에 비해 자동완성 기능과 오타 문제도 잡아주는 등 장점이 많기 때문에 tx스키마의 태그를 사용해 어드바이스를 등록하도록 권장한다.

##### 포인트컷과 트랜잭션 속성의 적용 전략
aop와 tx 스키마의 전용 태그를 사용한다면 애플리케이션의 어드바이저, 어드바이스, 포인트컷 기본 설정 방법은 바뀌지 않을 것이다. expression 애트리뷰트에 넣는 포인트컷 표현식과 <tx:attributes>로 정의하는 트랜잭션 속성만 결정하면 된다.

##### 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
일반적으로 트랜잭션을 적용할 타깃 클래스의 메서드는 모두 트랜잭션 적용 후보가 되는 것이 바람직하다. 앞선 예제에선 upgrade*의 메서드만 트랜잭션 처리했는데 비즈니스 로직을 담고있는 클래스라면 메서드 단위까지 세밀하게 포인트컷을 정의해줄 필요는 없다. 그리고 쓰기가 없고 읽기만 있는 타깃 클래스라도 트랜잭션을 적용하는 것이 성능향상에 도움이 된다. 트랜잭션에서 읽기전용으로 처리하게 된다면 트랜잭션을 처리하지 않은 클래스의 읽기보다 성능향상이 있다. 그리고 가능하면 클래스 타입으로 포인트컷 표현식을 처리하는 것보다 인터페이스 타입위주로 처리하는 것이 좋다. 인터페이스는 클래스에 비해 변경 빈도가 적고 일정한 패턴을 유지하기 쉽기 때문이다.

메서드의 시그니처를 이용한 execution() 방식의 포인트컷 표현식 대신 스프링의 빈 이름을 이용한 bean() 표현식을 사용하는 방법도 있다. bean() 표현식은 빈 이름을 기준으로 선정하기 때문에 클래스나 인터페이스 이름에 일정한 규칙을 만들기가 어려운 경우에 유용하다.

##### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메서드를 호출할 때는 적용되지 않는다.
이건 주의사항이다. 프록시 방식의 AOP에서는 프록시를 통한 부가기능의 적용 클라이언트로부터 호출이 일어날 때만 가능하다. 여기서 클라이언트는 인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트를 말한다.

클라이언트 --- request -> 트랜잭션 프록시 --- request -> 타깃

프록시에서 트랜잭션 처리를 진행하기 때문에 타깃에서 타깃 오브젝트 내에 메서드를 호출해도 트랜잭션이 적용되지 않는 것이다. 이런 상황의 경우 프록시 AOP를 통해 부여해준 부가기능이 적용되지 않는다는 점을 주의해야 한다. 이 문제를 해결 할 두 가지 방법이 있다.
1. 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메서드 호출도 프록시를 이용하도록 강제하는 방법이다. (기껏 핵심로직과 부가기능을 나눴는데 다시 호출하는 것은 비추천)
2. AspectJ와 같은 타깃 바이트코드로 직접 조작하는 방식의 AOP를 적용하는 것이다.


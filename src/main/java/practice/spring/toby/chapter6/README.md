# AOP
AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다. AOP를 바르게 이용하려면 OOP를 대체하려고 하는 것처럼 보이는 AOP라는 이름 뒤에 감춰진, 그 필연적인 등장배경과 스프링이 그것을 도입한 이유, 그 적용을 통해 얻을 수 있는 장점이 무엇인지에 대한 충분한 이해가 필요하다. 스프링에 적용된 가장 인기 있는 AOP의 적용대상은 선언적 트랜잭션 기능이다.

### 트랜잭션 코드의 분리
스프링이 제공하는 깔끔한 트랜잭션 인터페이스를 사용하였음에도 불구하고 비즈니스 로직의 주인이어야할 메서드 안에 트랜잭션 코드가 더 많은 자리를 차지하고 있다. 그렇다고해서 논리적으로 트랜잭션 코드를 다른 로직에서 처리하는 것은 맞지않다.

##### 메서드 분리
```JAVA
public void upgradeLevels() {
		// 트랜잭션 추상화 API를 적용
		TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); 
		
		// 비즈니스 로직 시작.
		try {
			List<User> users = userDao.getAll();
			for (User user : users) {
				if (changeUpgradeLevel(user)) {
					upgradeLevel(user);
				}
			}
		// 비즈니스 로직 끝.
		
			transactionManager.commit(status);
		} catch (Exception e) {
			transactionManager.rollback(status);
			throw e;
		} 
	}
```

비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있다. 또 이 코드의 특징은 트랜잭션 경계설정의 코드와 비즈니스로직 코드 간에 서로에게 요청하는 정보가 없다는 것이다. 비즈니스 로직에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 필요가 없다. 따라서 이 두 가지 코드는 성격이 다를 뿐 아니라 서로 주고받는 것도 없는 완벽하게 독립적인 코드다.

##### DI 적용을 이용한 트랜잭션 분리
구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점이다. 직접 사용하는 것이 문제가 된다면 간접적으로 사용하면된다. DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접적으로 접근하는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변결할 수 있다. 바로 이런 개념을 가진 DI가 지금 필요하다. 
(예제 practice.spring.toby.chapter6 : UserServiceTx, UserServiceImple )

##### 트랜잭션 경계설정 코드 분리의 장점
1. 비즈니스 로직을 담당하고 있는 UserServiceImple의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다. 스프링의 JDBC나 JTA 같은 로우레벨의 트랜잭션 API는 물론이고 스프링의 트랜잭션 추상화 API조차 필요 없다. 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.

##### 복잡한 의존관계 속 테스트
복잡한 의존관계를 갖는 오브젝트들이 테스트를 진행되는 동안에 같이 실행된다. 더 큰 문제는 그 세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 것이 아니라는 점이다. 의존관계 오브젝트 역시 다른 오브젝트의 의존관계를 갖고 있다면 꼬리물기 식으로 계속 오브젝트가 실행된다. 그 어느 것이라도 바르게 셋업되어 있지 않거나, 코드에 문제가 있다면 그 때문에 우리가 테스트하려는 오브젝트에 대한 테스트가 실패해버린다. 이런 경우의 테스트는 준비하기 힘들고, 환경이 조금이라도 달라지면 동일한 테스트 결과를 내지 못할 수도 있으며, 수행 속도는 느리고 그에 따라 테스트를 작성하고 실행하는 빈도가 점차로 떨어질 것이 분명하다.

##### 테스트 대상 오브젝트 고립시키기
그래서 테스트 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. 예시로 MailSender인터페이스를 고립시키는 DummyMailSender 같은 클래스가 있다. 또는 MockMailSender라는 목 오브젝트도 사용했다.

##### 고립된 단위 테스트 활용
예제 Chapter6UserServiceTest

다섯 단계의 테스트
1. 테스트 실행에 필요한 유저 DB 데이터 주입.
2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트 DI
3. 실제 테스트 대상인 UserServiceImple 의 메서드 실행
4. 결과가 DB에 반영됐는지 확인하기 위해 UserDao를 통한 데이터 가져오기 (UserServiceImple의 upgradeLevels())
5. 목 오브젝트를 통한 UserServiceImple에 의한 메일 발송이 있었는지 확인.

##### 단위 테스트와 통합 테스트
단위테스트 : 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것
통합테스트 : 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
- DB와 연동하는 오브젝트의 경우 분리해서 단위테스트로 만들기 힘들기 때문에 DB까지 하나로 묶어서 단위테스트로 진행한다.
- 각각의 단위테스트에서 성공하였더라도 단위테스트를 연결하여 통합테스트를 진행했을 때 오류가 발생할 수도 있다. 하지만 단위테스트에서 오류가 없었기 때문에 오류를 발견하기가 훨씬 수월하다.
- 단위테스트를 만들기가 너무 복잡하다고 판단되면 통합테스트를 고려한다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트이다. (JUnit)

테스트 코드를 만들려는 노력을 게을리하면 테스트 작성이 불편해지고, 텟트ㅡ를 잘 만들지 않게 될 가능성이 높아진다. 테스트가 없으니 과감하게 리팩토링 할 엄두를 내지 못할 것이고 코드의 품질은 점점 떨어지고 유연성과 확장성을 잃어갈지 모른다.

##### 목 프레임워크
목 오브젝트를 만들 때 테스트에서는 사용하지 않는 인터페이스도 모두 일일이 구현해줘야한다. 검증 기능이 있는 목 오브젝트를 만들려면, 메서드의 호출 내용을 저장했다가 이를 다시 불러오는 것도 매번 귀찮은 일이 아닐 수 없다. (JavaMail, MockUserDao ... ) 다행이도 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.

##### Mockito 프레임워크
Mockito 프레임워크는 사용하기도 편리하고, 코드도 직관적이라 최근 많은 인기를 끌고 있다.
목 오브젝트 사용 네가지 단계 * 두 번째와 네 번째는 각각 필요할 경우에만 사용할 수 있다.
1. 인터페이스를 이용해 목 오브젝트를 만든다.
2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메서드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
4. 테스트 대상 오브젝틀ㄹ 사용한 후에 목 오브젝트의 특정 메서드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

- times() : 메서드의 호출 횟수를 검증해준다.
- any()    : 파라미터의 내용은 무시하고 호출 횟수만 확인할 수 있다.
- verify().update(users.get(1)) : users.get(1)을 파라미터로 update() 호출된 적 있는지 확인해준다. update()가 호출된적이 없거나 파라미터가 users(1) 이 아니라면 테스트는 실패한다.

MailSender의 경우 ArgumentCaptor을 사용하여 실제 MailSender 목 오브젝트에 전달된 파라미터를 가져와 내용을 검증하는 방법을 사용했다. 파라미터를 직접 비교하기보다 파라미터의 내부 정보를 확인해야 하는 경우에 유용하다.

### 다이나믹 프록시와 팩토리 빈
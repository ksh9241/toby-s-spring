# 테스트
스프링을 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다.

##### 웹을 통한 DAO 테스트 방법의 문제점
DAO 뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다. 또한 테스트를 진행하는 중에 에러가 발생했을 경우 문제를 찾아야 하는 수고도 필요하다. 하나의 테스트를 수행하는데 참여하는 클래스와 코드가 너무 많기 때문이다.

##### 작은 단위 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 단위테스트는 개발한 기능이 원하는대로 정상작동하는지 확인할 수도 있으며, 이런 단위테스트를 하지않고 나중에 통합테스트에서 문제가 발생한다면 찾는것도, 해결하는 시간도 훨씬 오래 걸릴 것이다.

##### 자동수행 테스트 코드
테스트를 하기 위해 url을 입력하고 인풋값을 작성하고 브라우저를 실행하는 등 테스트를 수동으로 작업해야 하는 양이 많아질수록 테스트를 하기가 싫어진다. 1장에서 UserDaoTest 클래스의 경우 UserDao 오브젝트를 생성하고 DI를 통해 생성된 DB커넥션의 빈을 주입한 뒤 값만 입력하게된다면 IDE에서 1초면 테스트를 실행할 수 있었다. 이처럼 테스트는 최대한 간단하고, 자주 수행해도 부담이 없어야 좋다.

##### 수동확인 작업의 번거로움
main() 메서드에서 테스트코드를 작성하는 것은 자동으로 수행하도록 만들어졌다. 하지만 테스트의 결과값을 확인하는 것은 개발자의 몫이다. main() 메서드는 단순하게 콘솔에 우리가 원하는 값을 출력할 뿐이다.이렇게 결과를 개발자가 확인해야 하기때문에 완전 자동화된 테스트코드라고 말할 수 없다.

##### 실행 작업의 번거로움
아무리 main() 메서드로 간단히 실행할 수 있다고 하더라도 테스트케이스가 수백개가 된다면 수백개의 main 메서드를 실행하는 것도 쉽지않을 것이다.

##### JUnit
JUnit은 프레임워크이다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main() 메서드도 필요없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

##### 검증 코드
기존의 if/ else 로 테스트를 체크하던 부분에서 JUnit이 제공해주는 assertThat이라는 스태틱 메서드를 이용한다. assertThat()은 첫 번째 파라미터의 값을 뒤에 나오는 매처matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is() 는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.

### 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다. 대부분의 자바 IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있어서 더욱 편리하게 JUnit 테스트를 만들고 활용할 수 있게 해준다.

##### JUnit 테스트 실행 방법
자바의 대표적인 IDE 이클립스에서는 run -> runAs -> JUnit을 실행하면 @Test 어노테이션이 있는 메서드를 테스트한다. scope는 클래스에서 실행하면 클래스, 패키지에서 실행 시 패키지의 모든 테스트 메서드가 실행된다. JUnitCore.main으로 실행하는 것보다 훨씬 편리하다. 단축키로는 Alt+Shift+X->T를 순서대로 누르면 바로 실행된다.

##### 테스트 결과의 일관성
반복적인 테스트를 수행했을 떄 성공과 실패의 경우가 모두 존재한다면 좋은 테스트라고 할 수 없다. DB 서버가 다운됐다거나 네트워크에 장애가 생겨서 DB에 접근하지 못한다는 그런 특별한 예외를 제외하곤 테스트는 몇번을 반복해도 동일한 값을 반환해야 한다. 또한 주의사항으로 JUnit의 경우 특정한 테스트 메서드의 실행순서를 보장해주지 않는다. 실행순서에 따른 테스트의 결과값이 다르다면 잘못된 테스트 케이스를 작성한 것이다. 테스트 코드는 항상 독립적으로 동일한 결과를 낼 수 있도록 해야한다.

##### 포괄적인 테스트
간단한 코드의 경우 어느정도 경험이 있는 개발자라면 테스트코드를 작성하지않고도 문제가 생기지 않다는 것을 확인할 것이다. 하지만 이런 간단한 코드에서도 특별한 상황에 엉뚱한 결과값을 가져올 수 있다. 이럴 때 테스트코드를 작성하지 않았다면 원인을 찾기 힘들어서 고생하게 될 지도 모른다. 그리고 개발자들이 자주하는 실수 중 하나가 성공테스트만 진행하는 것이다. 대다수의 개발자들이 성공테스트를 확인 후 빠르게 다음 개발을 하러가는 경우가 많기 때문에 실패케이스부터 만드는 것을 추천한다. 또한 테스트의 경우 경계값 테스트를 통해 최대값 실패, 최소값 실패, 최대값 성공, 최소값 성공 등 경계값에 따른 테스트를 진행하는 것이 효율적이다.

##### 기능설계를 위한 테스트
|      |단계	       |내용				 |코드|
|---|------|---|---|
|조건|어떤 조건을 가지고|가져올 사용자 정보가 존재하지 않는 경우에|dao.deleteAll();  assertThat(dao.getCount(), is(0));|
|행위|무엇을 할 때         |존재하지 않는 id로 get()을 실행하면	|get("unknown_id");|
|결과|어떤 결과가 나온다|특별한 예외가 던져진다. 		|@Test(expected = EmptyResultDataAccessException.class)|

이렇게 비교해보면 이 테스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다. 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수도 있다.

##### 테스트 주도 개발
TDD : 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이다. "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다." 는 것이 TDD의 기본원칙이다.
TDD를 하지않고 개발을 하다보면 테스트케이스를 작성하지 않거나, 성의없는 테스트케이스로 인한 정확한 테스트 결과가 나오지 않을 수도 있다. TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다. 개발한 코드의 오류는 빨리 발견할수록 좋다. 빨리발견하면 쉽게 대응이 가능하다.
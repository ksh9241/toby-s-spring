# 스프링 프로젝트 시작하기

### 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스를 제공하도록 되어 있다. 즉 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고 그 결과를 돌려주는 것이 기본적인 동작 방식이다.

##### 클라이언트와 백엔드 시스템
가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다. 웹 브라우저에서 동작하기는 하지만, HTML을 사용하는 표준 웹 클라이언트 외에도 Flex나 X인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA(Rich Internet Application) 클라이언트가 사용되기도 한다.

##### 애플리케이션 서버
스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요하다. JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다.
하나는 JavaEE의 표준 기술을 지원하고 다양한 형태의 모듈로 배포가 가능한 완전한 웹 애플리케이션 서버 WAS이고, 다른 하나는 웹 모듈의 배포만 가능한 경량급 WAS 또는 서블릿/JSP 컨테이너다.

- 경량급 WAS/서블릿 컨테이너

스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다. 기존에 EJB와 WAS를 사용해야 가능했던 선언적인 트랜잭션이나 선언적 보안, DB 연결 풀링, 리모팅이나 웹 서비스는 물론이고 추가적인 라이브러리의 도움을 받으면 분산/글로벌 트랜잭션까지도 가능하다.

- WAS

고가의 WAS를 사용하면 그만큼 장점이 있다. 성능 면에서는 대단히 낫지 않더라도 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리, 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용하는 등의 필요가 있다면 상용 또는 오픈소스 WAS를 이용할 수 있다.
WAS를 사용할 때는 분명한 이유와 근거가 있는지 먼저 충분히 검토해야 한다. 훨씬 가볍고 빠르며 저렴한 비용으로 사용 가능한 서블릿 컨테이너로도 대개는 충분한데 특별한 이유도 없이 무겁고 비싼 WAS를 사용할 필요는 없기 때문이다.

##### 스프링소스 tcServer
tcServer를 이용하면 기존 톰캣에서는 아쉬웠던 고급 서버 관리 기능, 배포 기능과 진단 기능을 포함해서 톰캣 전문가에게 받는 기술지원도 함께 제공받을 수 있다. tcServer의 가장 큰 장점은 스프링 개발회사가 개발하는 것인 만큼 스프링 애플리케이션 개발과 운영에 꼭 필요한 중요한 기능이 많이 제공된다는 점이다.

##### 스프링 애플리케이션의 배포 단위
- 독립 웹 모듈

스프링은 모통 war로 패키징된 독립 웹 모듈로 배포한다. 톰캣같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다. WAS로 배포한다고 하더라도 독립 웹 모듈을 사용하는 경우가 대부분일 것이다.

- 엔터프라이즈 애플리케이션

경우에 따라선 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있다.
스프링 애플리케이션에서 EJB 모듈을 긴밀하게 사용하거나 반대로 EJB모듈에서 스프링으로 만든 애플리케이션을 이용해야 한다면, EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야 한다.

- 백그라운드 서비스 모듈

이 두 가지 방법 외에도 J2EE 1.4에서 등장한 rar 패키징 방법도 있다. rar은 리소스 커넥터를 만들어 배포할 때 사용하는 방식인데, 만약 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어 배포할 수 있다.

### 애플리케이션 아키텍처
아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다.

##### 계층형 아키텍처
성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

##### 아키텍처와 SoC
성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리하고, 그 사이에 유연한 결합을 가질 수 있도록 인터페이스를 두고 그 관계를 맺어주는 제 3의 존재인 DI 컨테이너를 둬서 오브젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로 한 유연한 설계와 구현 전략이었다.
이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다. 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나눌 수가 있다.

만약 나누어져 있지 않다면 SQL과 JDBC의 코드와 HTML 태그 사이에 읽어온 정보가 함께 존재할 수도 있다. 대표적인 예시로는 MVC1 패턴의 JSTL이 그 대표적이다. 확실히 읽기싫은 코드이면서 수정하고 싶지 않은 코드이다. 그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다. 이렇게 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다. 또 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.

이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키텍처라고 부른다. 혹은 멀티 티어 아키텍처라고도 한다.

##### 3계층 아키텍처와 수직 계층
1. 데이터 액세스 계층 : 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 한다.
2. 서비스 계층 : 비즈니스 로직을 담고 있다.
3. 프레젠테이션 계층 : 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리한다.

- 데이터 액세스 계층

DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 사용하기 때문이다. 데이터 액세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 내부에서 추상화 계층 구조에 따라서 진행 순서를 분리하기도 한다. 추상화 레벨이 낮은 게 아래에 위치한다.

|DAO 코드|
|jdbcTemplate|
|JDBC|트랜잭션 동기화|
|DataSource|

- 서비스 계층

서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 
비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층은 이름 때문에 혼동되기 쉬우므로 주의하자.
기반 서비스 계층에는  트랜잭션, 보안, 리모팅, 메시징, 메일, 스케줄링 등이 있다.

원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거해야 한다. 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.

- 프레젠테이션 계층

프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다. 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. 자바에서 HTTP 프로토콜을 처리하는 가장 기본 엔진이 서블릿 기술을 바탕으로 한다. 모든 프레젠테이션 로직은 서버의 프레젠테이션 계층의 컴포넌트에서 처리된다. 화면 흐름을 경정하는 것이나 사용자 입력 값에 대한 검증, 서비스 계층의 호출과 전달되는 값의 포맷의 변화, 뷰라고 불리는 화면을 어떻게 그릴지에 대한 로직 등이 모두 서버에서 처리됐다. (이때까지만 해도 컨트롤러가 그 역할을 하는 것으로 보임) 하지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다 RIA라 불리는 기술이나 SOFEA(Service Oriented Front End Architecture) 가 대표적인 예다.

##### 계층형 아키텍처 설계의 원칙
각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다. 각 계층은 자신의 계층의 책임에만 충실해야 한다. 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다. 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다. 그렇게 되면 필요한 그 밖의 작업은 다른 계층에 요청하게 될 것이다.

또 흔히 저지르는 실수 중 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다. HttpServletRequest나 HttpServlerResponse, HttpSession 같은 타입을 서비스 계층 인터페이스 메서드의 파라미터 타입으로 사용하면 안 된다. 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다. (ex : DTO, VO ) 만약 서비스 계층의 코드에 웹 프레젠테이션 계층의 기술이 있다면 웹 방식의 클라이언트가 아닌 다른 시스템에서 요청을 받아서 처리해야 하는 경우에는 웹 기술에 종속된 코드는 재사용이 불가능해진다. 더 큰 문제는 테스트다. 서비스 계층에 웹 관련 오브젝트가 존재하면 POJO 기반의 빠르고 간단한 단위 테스트를 작성하기 힘들어진다.

어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.

##### 애플리케이션 정보 아키텍처
엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다. 애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS 백엔드 시스템에 저장된다. 하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.

엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우, 두 가지 기준으로 구분해볼 수 있다.
데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다. DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠테이션 계층의 뷰, 즉 사용자가 보는 화면에 연결해주는 것이다.
이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 에터프라이즈 애플리케이션과 크게 다를 바 없다. 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 담겨 있는 경우가 많다는 점이다.
데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

##### DB/SQL 중심의 로직 구현 방식
데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다.

- DB중심의 아키텍처 구조

하나의 업무 트랜잭션에 참여하는 코드가 일괄적으로 만들어진다. 대부분 재사용이 불가능하다. 이동하는 정보는 대부분 SQL 결과를 담은 단순 데이터다.
서비스 계층 : 하나 또는 그 이상의 SQL을 호출하는 것이 대부분인 통짜 업무 트랜잭션이다. DAO의 결과를 그대로 조회 화면으로 전달하는 경우가 대부분이다.
데이터 액세스 계층 : 주요 비즈니스 로직은 SQL과 DB에 존재한다. 애플리케이션의 핵심이 SQL과 DB 안에서 실행되는 저장 프로시저에 담겨 있다.

이런 방식은 개발하기 쉽다는 장점이 있다. 대부분의 개발자는 이미 복잡한 로직을 SQL로 작성하는 데 익숙하다. 계층으로 세분화되기는 하지만 업무 트랜잭션, 또는 요구사항별로 구분해서 코드로 만드는 건 쉽다. 하지만 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다. 겉으로 보기에는 각 계층이 독립적으로 보이지만, 그 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 한다.
그리고 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지 못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다. 중복을 제거하기도 쉽지 않다. 또한 로직을 DB와 SQL에 많이 담으면 담을수록 점점 확장성이 떨어진다. DB는 확장에 한계가 있을 뿐 아니라 확장한다 하더라도 매우 큰 비용이 든다.
상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이 적게 든다. 서버를 늘려 쉽게 확장할 수도 있다. 따라서 로직을 DB보다는 애플리케이션으로 가져오는 편이 유리한 점이 많다. 비용도 저렴해질 뿐 아니라 안정성도 높아지고 코드를 검증하기도 매우 편하다. 게다가 테스트 하기도 프로시저보다 수월하다.

##### 거대한 서비스 계층 방식
DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다. 여전히 SQL의 결과를 그대로 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL 에서 서비스 계층의 오브젝트로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.

거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다. DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다. 비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메서드가 만들어질 가능성이 높은데, 그러다 보면 하나의 메서드가 매우 거대해지기도 한다.

- 거대 서비스 계층 방식 아키텍처 구조

DAO를 일부 재사용해서 핵심 로직을 구현하지만 여전히 특정 업무 트랜잭션에 종속되는 데이터 구조를 갖기 쉽다.
서비스 계층 : 단순 조회가 아니라면 DAO가 돌려주는 값을 분석 또는 가공해서 비즈니스 로직을 만든다. 로직이 POJO로 되어 있기 때문에 테스트가 용이한 편이다.
데이터 액세스 계층 : 비즈니스 로직이 서비스 계층에 존재하기 때문에 SQL에 복잡한 로직을 담을 필요는 없다. DB에 큰 부하를 주지 않는 단순한 형태로 조회해서 그 결과를 서비스 계층에 전달해주기만 하면 된다.

DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다. 하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다.
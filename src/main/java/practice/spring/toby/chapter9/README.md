# 스프링 프로젝트 시작하기

### 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스를 제공하도록 되어 있다. 즉 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고 그 결과를 돌려주는 것이 기본적인 동작 방식이다.

##### 클라이언트와 백엔드 시스템
가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다. 웹 브라우저에서 동작하기는 하지만, HTML을 사용하는 표준 웹 클라이언트 외에도 Flex나 X인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA(Rich Internet Application) 클라이언트가 사용되기도 한다.

##### 애플리케이션 서버
스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요하다. JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다.
하나는 JavaEE의 표준 기술을 지원하고 다양한 형태의 모듈로 배포가 가능한 완전한 웹 애플리케이션 서버 WAS이고, 다른 하나는 웹 모듈의 배포만 가능한 경량급 WAS 또는 서블릿/JSP 컨테이너다.

- 경량급 WAS/서블릿 컨테이너

스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다. 기존에 EJB와 WAS를 사용해야 가능했던 선언적인 트랜잭션이나 선언적 보안, DB 연결 풀링, 리모팅이나 웹 서비스는 물론이고 추가적인 라이브러리의 도움을 받으면 분산/글로벌 트랜잭션까지도 가능하다.

- WAS

고가의 WAS를 사용하면 그만큼 장점이 있다. 성능 면에서는 대단히 낫지 않더라도 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리, 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용하는 등의 필요가 있다면 상용 또는 오픈소스 WAS를 이용할 수 있다.
WAS를 사용할 때는 분명한 이유와 근거가 있는지 먼저 충분히 검토해야 한다. 훨씬 가볍고 빠르며 저렴한 비용으로 사용 가능한 서블릿 컨테이너로도 대개는 충분한데 특별한 이유도 없이 무겁고 비싼 WAS를 사용할 필요는 없기 때문이다.

##### 스프링소스 tcServer
tcServer를 이용하면 기존 톰캣에서는 아쉬웠던 고급 서버 관리 기능, 배포 기능과 진단 기능을 포함해서 톰캣 전문가에게 받는 기술지원도 함께 제공받을 수 있다. tcServer의 가장 큰 장점은 스프링 개발회사가 개발하는 것인 만큼 스프링 애플리케이션 개발과 운영에 꼭 필요한 중요한 기능이 많이 제공된다는 점이다.

##### 스프링 애플리케이션의 배포 단위
- 독립 웹 모듈

스프링은 모통 war로 패키징된 독립 웹 모듈로 배포한다. 톰캣같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다. WAS로 배포한다고 하더라도 독립 웹 모듈을 사용하는 경우가 대부분일 것이다.

- 엔터프라이즈 애플리케이션

경우에 따라선 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있다.
스프링 애플리케이션에서 EJB 모듈을 긴밀하게 사용하거나 반대로 EJB모듈에서 스프링으로 만든 애플리케이션을 이용해야 한다면, EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야 한다.

- 백그라운드 서비스 모듈

이 두 가지 방법 외에도 J2EE 1.4에서 등장한 rar 패키징 방법도 있다. rar은 리소스 커넥터를 만들어 배포할 때 사용하는 방식인데, 만약 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어 배포할 수 있다.

### 애플리케이션 아키텍처
아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다.

##### 계층형 아키텍처
성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

##### 아키텍처와 SoC
성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리하고, 그 사이에 유연한 결합을 가질 수 있도록 인터페이스를 두고 그 관계를 맺어주는 제 3의 존재인 DI 컨테이너를 둬서 오브젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로 한 유연한 설계와 구현 전략이었다.
이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다. 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나눌 수가 있다.

만약 나누어져 있지 않다면 SQL과 JDBC의 코드와 HTML 태그 사이에 읽어온 정보가 함께 존재할 수도 있다. 대표적인 예시로는 MVC1 패턴의 JSTL이 그 대표적이다. 확실히 읽기싫은 코드이면서 수정하고 싶지 않은 코드이다. 그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다. 이렇게 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다. 또 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.

이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키텍처라고 부른다. 혹은 멀티 티어 아키텍처라고도 한다.

##### 3계층 아키텍처와 수직 계층
1. 데이터 액세스 계층 : 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 한다.
2. 서비스 계층 : 비즈니스 로직을 담고 있다.
3. 프레젠테이션 계층 : 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리한다.

- 데이터 액세스 계층

DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 사용하기 때문이다. 데이터 액세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 내부에서 추상화 계층 구조에 따라서 진행 순서를 분리하기도 한다. 추상화 레벨이 낮은 게 아래에 위치한다.

|DAO 코드|
|jdbcTemplate|
|JDBC|트랜잭션 동기화|
|DataSource|

- 서비스 계층

서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 
비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층은 이름 때문에 혼동되기 쉬우므로 주의하자.
기반 서비스 계층에는  트랜잭션, 보안, 리모팅, 메시징, 메일, 스케줄링 등이 있다.

원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거해야 한다. 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.

- 프레젠테이션 계층

프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다. 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. 자바에서 HTTP 프로토콜을 처리하는 가장 기본 엔진이 서블릿 기술을 바탕으로 한다. 모든 프레젠테이션 로직은 서버의 프레젠테이션 계층의 컴포넌트에서 처리된다. 화면 흐름을 경정하는 것이나 사용자 입력 값에 대한 검증, 서비스 계층의 호출과 전달되는 값의 포맷의 변화, 뷰라고 불리는 화면을 어떻게 그릴지에 대한 로직 등이 모두 서버에서 처리됐다. (이때까지만 해도 컨트롤러가 그 역할을 하는 것으로 보임) 하지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다 RIA라 불리는 기술이나 SOFEA(Service Oriented Front End Architecture) 가 대표적인 예다.

##### 계층형 아키텍처 설계의 원칙
각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다. 각 계층은 자신의 계층의 책임에만 충실해야 한다. 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다. 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다. 그렇게 되면 필요한 그 밖의 작업은 다른 계층에 요청하게 될 것이다.

또 흔히 저지르는 실수 중 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다. HttpServletRequest나 HttpServlerResponse, HttpSession 같은 타입을 서비스 계층 인터페이스 메서드의 파라미터 타입으로 사용하면 안 된다. 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다. (ex : DTO, VO ) 만약 서비스 계층의 코드에 웹 프레젠테이션 계층의 기술이 있다면 웹 방식의 클라이언트가 아닌 다른 시스템에서 요청을 받아서 처리해야 하는 경우에는 웹 기술에 종속된 코드는 재사용이 불가능해진다. 더 큰 문제는 테스트다. 서비스 계층에 웹 관련 오브젝트가 존재하면 POJO 기반의 빠르고 간단한 단위 테스트를 작성하기 힘들어진다.

어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.

##### 애플리케이션 정보 아키텍처
엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다. 애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS 백엔드 시스템에 저장된다. 하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.

엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우, 두 가지 기준으로 구분해볼 수 있다.
데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다. DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠테이션 계층의 뷰, 즉 사용자가 보는 화면에 연결해주는 것이다.
이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 에터프라이즈 애플리케이션과 크게 다를 바 없다. 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 담겨 있는 경우가 많다는 점이다.
데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

##### DB/SQL 중심의 로직 구현 방식
데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다.

- DB중심의 아키텍처 구조

하나의 업무 트랜잭션에 참여하는 코드가 일괄적으로 만들어진다. 대부분 재사용이 불가능하다. 이동하는 정보는 대부분 SQL 결과를 담은 단순 데이터다.
서비스 계층 : 하나 또는 그 이상의 SQL을 호출하는 것이 대부분인 통짜 업무 트랜잭션이다. DAO의 결과를 그대로 조회 화면으로 전달하는 경우가 대부분이다.
데이터 액세스 계층 : 주요 비즈니스 로직은 SQL과 DB에 존재한다. 애플리케이션의 핵심이 SQL과 DB 안에서 실행되는 저장 프로시저에 담겨 있다.

이런 방식은 개발하기 쉽다는 장점이 있다. 대부분의 개발자는 이미 복잡한 로직을 SQL로 작성하는 데 익숙하다. 계층으로 세분화되기는 하지만 업무 트랜잭션, 또는 요구사항별로 구분해서 코드로 만드는 건 쉽다. 하지만 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다. 겉으로 보기에는 각 계층이 독립적으로 보이지만, 그 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 한다.
그리고 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지 못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다. 중복을 제거하기도 쉽지 않다. 또한 로직을 DB와 SQL에 많이 담으면 담을수록 점점 확장성이 떨어진다. DB는 확장에 한계가 있을 뿐 아니라 확장한다 하더라도 매우 큰 비용이 든다.
상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이 적게 든다. 서버를 늘려 쉽게 확장할 수도 있다. 따라서 로직을 DB보다는 애플리케이션으로 가져오는 편이 유리한 점이 많다. 비용도 저렴해질 뿐 아니라 안정성도 높아지고 코드를 검증하기도 매우 편하다. 게다가 테스트 하기도 프로시저보다 수월하다.

##### 거대한 서비스 계층 방식
DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다. 여전히 SQL의 결과를 그대로 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL 에서 서비스 계층의 오브젝트로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.

거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다. DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다. 비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메서드가 만들어질 가능성이 높은데, 그러다 보면 하나의 메서드가 매우 거대해지기도 한다.

- 거대 서비스 계층 방식 아키텍처 구조

DAO를 일부 재사용해서 핵심 로직을 구현하지만 여전히 특정 업무 트랜잭션에 종속되는 데이터 구조를 갖기 쉽다.
서비스 계층 : 단순 조회가 아니라면 DAO가 돌려주는 값을 분석 또는 가공해서 비즈니스 로직을 만든다. 로직이 POJO로 되어 있기 때문에 테스트가 용이한 편이다.
데이터 액세스 계층 : 비즈니스 로직이 서비스 계층에 존재하기 때문에 SQL에 복잡한 로직을 담을 필요는 없다. DB에 큰 부하를 주지 않는 단순한 형태로 조회해서 그 결과를 서비스 계층에 전달해주기만 하면 된다.

DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다. 하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다.

##### 오브젝트 중심 아키텍처
오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것이다. 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다. 이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처다.

##### 데이터와 오브젝트
간단한 예시로 카테고리 테이블과 상품 테이블이 있다고 생각해보자. 카테고리 1 : N 상품 의 관계가 그려진다. 이때 데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각한다. 이 두개의 정보를 조합해서 가져오는 방법은 JOIN을 이용해 2차원 구조의 정보를 만드는 것이다. (컬럼, 로우) 보통 서버에서 List<Object> 타입이나 List<Map<String, Object>> 타입으로 조회된 데이터를 담는다. 하지만 이 때 서비스 계층이나 프레젠테이션 계층의 코드에서는 DAO 메서드에서 조회를 통한 데이터를 넣어줬다는 사실을 알아야 사용할 수 있다. SQL을 통해서 가공된 데이터의 구조를 알고 이를 활용하는 것이 전부다.
이렇게 데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 된다.

반면 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.

```JAVA
public class Category {
	int categoryId;
	String description;
	Set<Product> products;

	// 접근자, 수정자...
}

public class product {
	int productId;
	String name;
	Category category;

	// 접근자, 수정자...
}
```

자바에서는 관계하고 있는 다른 오브젝트와 직접 연결하는 방법이 있다. 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 것이다. 하나 이상의 오브젝트와 관계를 가지려면 컬렉션을 이용할 수도 있다.
그래서 product에서 categoryId를 따로 가질 필요없이 Category타입의 레퍼런스 변수를 갖고 있다. 또한 Category 역시 Set의 Product타입으로 products의 레퍼런스 변수를 가지고 중복을 제거한 값을 가질 수 있다.
이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다. DAO는 자신이 DB에서 가져와서 도메인 모델 오브젝트에 담아주는 정보가 어떤 업무 트랜잭션에서 어떻게 사용될지는 신경쓰지 않아도 된다. 서비스 계층 또한  DAO에서 어떤 SQL을 사용했는지 몰라도 된다.

##### 도메인 오브젝트를 사용하는 코드
도메인 오브젝트를 사용하는 장점은 DB중심이 아니기 때문에 DB에서 출력된 데이터를 가공할 때 간편하다. 예로 조회된 데이터의 가격을 모두 더한 값을 가져오고 싶을 때 루프를 돌면서 간단히 로컬변수에 값을 담아 반환하면 된다. 하지만 DB중심의 아키텍처의 경우 select sum(p.price) 등 쉽지않은 쿼리를 통해 작성해야 하며 SQL을 확인하지 않으면 어떤 목적을 위한 결과값인지 알기가 어렵다. 또한 DB중심의 경우 같은 데이터가 조건이 다른 결과값을 구하려고 할 때 중복된 SQL을 실행하여 결과값을 가져오게 된다. 반면 오브젝트 방식의 경우 한번의 데이터 조회 이후 메서드를 통한 재사용 가능한 경우의 수를 만들 수 있다.

##### 도메인 오브젝트 사용의 문제점
최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다. 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 필드뿐이라면 DAO에서 도메인 오브젝트에 모든 필드 정보를 채워서 전달하는 것은 낭비일 수도 있다. 또한 product오브젝트가 있다고 가정하고 연관관계로 category 오브젝트가 있다고 했을 때 프레젠테이션 영역에서는 product의 데이터가 필요하지만 도메인 오브젝트를 사용할 경우 product안에있는 category 필드의 데이터까지 조회 후 바인딩 시켜서 반환하기 때문에 필요하지 않을 데이터를 조회해서 처리하는 것 또한 상당한 낭비다.

이런 문제를 해결하는 접근방법은 여러가지가 있다. lazy loading (지연로딩) 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이나믹하게 DB에서 다시 읽어올 수 있다. 실제 도메인 오브젝트를 사용하는 곳에서는 이런 사실을 인지하지 않고 평소대로 사용하면 된다.
사실 가장 이상적인 방법은 JPA나 JDO, 하이버네이트와 같은 오브젝트 매핑 (RDB) 기술을 사용하는 것이다. 이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다.
코드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB에서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB의 부하를 줄여줘서 성능이 많이 향상된다.

그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다.
ORM을 사용하지 않고 JDBC를 이용하는 경우라면 지연된 로딩 기법을 제공하는 코드를 추가해주거나, 사용되는 필드의 종류와 사용되는 고나련 오브젝트의 범위에 따라서 여러 개의 DAO 메서드를 만들어 사용해야 할 수도 있다. 이 경우 DAO 코드나 도메인 오브젝트 코드의 중복이 일부 발생하고 계층 사이의 결합도도 증가될 수는 있지만, 데이터 중심 아키텍처에 비하면 미미한 정도다.

오브젝트 중심의 아키텍처는 도메인 모델을 따르는 오브젝트를 사용해 각 계층 사이에 정보를 전달하고, 이를 이용해 비즈니스 로직이나 프레젠테이션 로직을 작성한다. 계층 간의 결합도는 낮아지고 일관된 정보 모델을 사용하기 때문에 개발 생산성과 코드의 품질, 테스트 편의성도 향상시킬 수 있다.

##### 빈약한 도메인 오브젝트 방식
도메인 오브젝트에 정보만 담겨있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다. 그래서 이런 오브젝트를 빈약한 오브젝트라고 부른다.
스프링 개발자가 흔히 사용하는 방식이 이 빈약한 도메인 오브젝트 방식이라고 볼 수 있다. DTO, VO 등 데이터들 담는 빈약한 오브젝트이면서 모든 계층에서 활용하도록 하고 있기 떄문에 깔끔하고 유연한 코드를 만들 수 있다.

도메인 오브젝트라는 일관된 오브젝트를 활용하기 때문에 SQL에 의존적인 데이터 방식보다는 훨씬 유연하고 간결하지만, 여전히 서비스 계층의 메서드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다. 하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘 살려서 개발할 수 있는 유용한 아키텍처다.

##### 풍성한 도메인 오브젝트 방식
풍성한 도메인 오브젝트 또는 영리한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다. 
도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메서드에 따로 만드는 경우보다 응집도가 높다. 데이터와 그것을 사용하는 기능이 한곳에 모여있기 때문이다.

물론 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던 서브시 계층 오브젝트가 필요 없어지는 건 아니다. 여전히 서비스 계층은 필요하며 중요한 역할을 하고 있다. 도메인 오브젝트 안에 들어있는 메서드는 대부분 해당 오브젝트나, 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용한다.
도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하다. 도메인 오브젝트가 접근할 수 없는 이유는 스프링 컨테이너가 관리하는 오브젝트, 즉 빈이 아니기 때문이다.

만들지 못하는 이유는 도메인 오브젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리, JDBC 템플릿 등에 의해 필요할 때마다 새롭게 만들어진다. 그러므로 스프링 컨테이너가 관리하지 못하기 때문에 빈으로 생성할 수 없으며 DI할 수 없다.
그래서 수식 계산, 조건에 따른 데이터 변경 등 오브젝트 자신에 국한된 로직만 도메인 오브젝트에 추가할 수 있다.

스프링의 빈으로 관리되는 3계층 (프레젠테이션, 서비스, 데이터액세스)의 오브젝트들은 도메인 오브젝트를 자유롭게 사용할 수 있지만 그 반대는 안된다는 사실을 주의해야 한다. (도메인 오브젝트가 빈이 아니기 때문)

##### 도메인 계층 방식
도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다. 그래서 등장한 것이 바로 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다. 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 하는 것이다.

기존 방식과 다른 두 가지 특징을 갖는다.
1. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점이다.
도메인 오브젝트에게 비즈니스 로직의 처리를 요청할 수 있다. 일단 도메인 계층으로 들어가면 서비스 계층의 도움 없이도 비즈니스 로직의 대부분의 작업을 수행할 수 있다는 뜻이다.

2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다.
하지만 도메인 오브젝트는 스프링에 등록돼서 싱글톤으로 관리되는 빈이 아니기 때문에 다른 빈을 DI 받을 수 없다. 하지만 스프링이 관리하지 않는 오브젝트에도 DI를 적용할 수 있다. 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다. 간단한 스프링 AOP는 적용대상이 스프링의 빈 오브젝트 한정이기 때문에 사용할 수 없고 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다.

이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받게 할 수 있다. 이 덕분에 도메인 오브젝트 기능의 제약이 사라진다. 그럼에도 서비스 계층의 역할이 완전히 사라지는 것은 아니다. 때로는 여러 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우가 있다. 이런 경우 서비스 계층에서 도메인 계층과 협력을 통해 진행하는 것이 바람직하다. 
또는 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 하는 기반 서비스를 이요해야 하는 작업을 위해서라도 서비스 계층은 필요하다.

도메인 오브젝트를 독립적인 계층으로 만들 때 고려해야 할 중요한 사항도 있다. 도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보 전달 도구 같은 역할을 했다. 하지만 독자적인 계층을 이뤘을 때는 상황이 달라질 수 있다.

1. 여전히 모든 계층에서 도메인 오브젝트를 사용한다.
가장 손쉽고 편한 방법이다. 도메인 모델을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대로 누릴 수 있다. 하지만 주의하지 않으면 심각한 혼란을 초래할 수 있다. 도메인 오브젝트가 독립적인 계층이 되면 단순한 값의 조작이나 분석 정도가 아니라 중요한 도메인/비즈니스 로직을 담당하고 있다. 심지어 DB나 백엔드 시스템에 작업 결과를 반영할 수도 있다. 이런 막강한 기능의 오브젝트를 프레젠테이션 계층이나 프론트 등에서 사용하게 해주면 위험이 뒤따를 수 있다.

해결방법은 철저한 개발 가이드라인을 만들어두고 이를 강력하게 적용하는 것이다. 여기서 문제는 이를 어기는 개발자가 있다는 점인데 이런 문제는 코딩 정책의 적용을 분석할 수 있는 툴을 이용해 검증하거나 AspectJ의 정책/표준 강화제 기능을 사용하면 된다.

2. 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다.
도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다. 이런 오브젝트는 DTO라고 불린다. DTO는 상태변화를 허용하지 않고 읽기전용으로 만들어지기도 한다. DTO는 기능을 갖지 않으므로 사용하기 안전하다.

도메인 계층은 기존 3계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만 그 특성은 확연히 다르다. 서비스를 제공하는 싱글톤으로 계속 존재하는 다른 계층의 오브젝트와 달리, 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복한다. 도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문이다.

상태정보를 담고 있기 때문에 스레드를 공유하는 싱글톤이 될 수 없다. 앞서 말했듯이 AspectJ를 사용해서 특별한 방법으로 DI를 해서 도메인 계층으로 만들어줘야 한다. 이러한 제약과 불편을 감소하고도 도메인 계층을 생성하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 때다. 도메인 계층은 응집도가 매우 높기 때문에 단위 테스트를 작성하기가 편리하다.
따라서 도메인 계층을 이용하는 방식을 선택할 때는, 오브젝트 중심 아키텍처의 기본 두 가지 방법을 충분히 경험해보고도 오브젝트 중심의 개발 방식에 익숙해진 뒤 조심스럽게 접근해야 한다.